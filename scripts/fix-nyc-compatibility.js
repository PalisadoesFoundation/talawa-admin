#!/usr/bin/env node
/**
 * Postinstall script to fix nyc compatibility with Node.js v24.
 * This creates a wrapper for nyc that intercepts merge and report commands
 * and uses custom scripts instead. It also handles Cypress code-coverage calls
 * gracefully to prevent test hangs.
 */

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function fixNycCompatibility() {
  // Possible nyc installation locations (npm + pnpm)
  const possiblePaths = [
    path.join(process.cwd(), 'node_modules', 'nyc', 'index.js'),
    path.join(
      process.cwd(),
      'node_modules',
      '.pnpm',
      'nyc@17.1.0',
      'node_modules',
      'nyc',
      'index.js',
    ),
  ];

  let nycPath = null;

  for (const p of possiblePaths) {
    if (fs.existsSync(p)) {
      nycPath = p;
      break;
    }
  }

  if (!nycPath) {
    console.log('nyc not found, skipping compatibility fix');
    return;
  }

  try {
    const content = fs.readFileSync(nycPath, 'utf8');

    if (content.includes('NYC_WRAPPER_V24')) {
      console.log('nyc already wrapped for Node.js v24 compatibility');
      return;
    }

    console.log('Creating nyc wrapper for Node.js v24 compatibility...');

    // Find scripts/ directory from project root
    let projectRoot = process.cwd();
    let scriptsDir = path.join(projectRoot, 'scripts');

    while (
      !fs.existsSync(scriptsDir) &&
      projectRoot !== path.dirname(projectRoot)
    ) {
      projectRoot = path.dirname(projectRoot);
      scriptsDir = path.join(projectRoot, 'scripts');
    }

    if (!fs.existsSync(scriptsDir)) {
      console.error('Could not find scripts directory');
      return;
    }

    const wrapperContent = `#!/usr/bin/env node
// NYC_WRAPPER_V24 - Autogenerated wrapper for Node.js v24 compatibility

const { spawn } = require("child_process");
const path = require("path");
const fs = require("fs");

// Distinguish CLI vs programmatic usage (Cypress uses require())
const isCLI = require.main === module;

if (!isCLI) {
  // Programmatic usage: load the original nyc module
  const backupPath = __filename + ".backup";
  let original = null;

  if (fs.existsSync(backupPath)) {
    delete require.cache[__filename];
    original = require(backupPath);
  } else {
    const dir = path.dirname(__filename);
    const alt = path.join(dir, "index.js.backup");
    if (fs.existsSync(alt)) {
      delete require.cache[__filename];
      original = require(alt);
    }
  }

  if (!original) {
    throw new Error("Original nyc module not found.");
  }

  module.exports = original;
  return;
}

// CLI mode:
let projectRoot = process.cwd();
let scriptsDir = path.join(projectRoot, "scripts");

// Walk upward to locate scripts/
if (!fs.existsSync(scriptsDir)) {
  while (!fs.existsSync(scriptsDir) && projectRoot !== path.dirname(projectRoot)) {
    projectRoot = path.dirname(projectRoot);
    scriptsDir = path.join(projectRoot, "scripts");
  }
}

const args = process.argv.slice(2);
const command = args[0];

// Detect Cypress coverage plugin calls
const isCypressCall =
  (!command || command.startsWith("--")) &&
  (args.some(a => a.startsWith("--projectRoot")) ||
    (args.includes("--reporter") && args.some(a => a.includes("json-summary"))) ||
    (args.length > 0 && args[0].startsWith("--") && !args.includes("merge") && !args.includes("report")));

// Short-circuit Cypress coverage calls to avoid timeouts
if (isCypressCall) {
  console.log("[NYC WRAPPER] Handling Cypress coverage call...");

  const summaryFile = path.join(process.cwd(), ".nyc_output/out.json");
  const summaryDir = path.dirname(summaryFile);

  if (!fs.existsSync(summaryDir)) {
    fs.mkdirSync(summaryDir, { recursive: true });
  }

  const minimalSummary = {
    total: {
      lines: { pct: 0 },
      statements: { pct: 0 },
      functions: { pct: 0 },
      branches: { pct: 0 },
    }
  };

  fs.writeFileSync(summaryFile, JSON.stringify(minimalSummary, null, 2), "utf8");

  console.log("[NYC WRAPPER] Wrote minimal coverage summary for Cypress.");
  process.exit(0);
}

// MERGE COMMAND
if (command === "merge") {
  const inputDir = args[1] || "./coverage/tmp";
  const outputFile = args[2] || "./.nyc_output/coverage-final.json";
  const mergeScript = path.join(scriptsDir, "merge-coverage.js");

  if (!fs.existsSync(mergeScript)) {
    console.error("Merge script not found:", mergeScript);
    process.exit(1);
  }

  const child = spawn("node", [mergeScript, inputDir, outputFile], {
    stdio: "inherit",
    cwd: process.cwd(),
    env: { ...process.env, NODE_NO_WARNINGS: "1" },
  });

  child.on("exit", (code) => process.exit(code || 0));
  child.on("error", () => process.exit(1));
  return;
}

// REPORT COMMAND
if (command === "report") {
  const reporterIndex = args.indexOf("--reporter");
  const reportDirIndex = args.indexOf("--report-dir");

  let reporter = "lcov";
  let reportDir = "./coverage/vitest";

  if (reporterIndex !== -1 && args[reporterIndex + 1]) {
    reporter = args[reporterIndex + 1];
  }
  if (reportDirIndex !== -1 && args[reportDirIndex + 1]) {
    reportDir = args[reportDirIndex + 1];
  }

  if (reporter === "lcov") {
    const inputFile = "./.nyc_output/coverage-final.json";
    const outputFile = path.join(reportDir, "lcov.info");
    const generateScript = path.join(scriptsDir, "generate-lcov.js");

    if (!fs.existsSync(generateScript) || !fs.existsSync(inputFile)) {
      console.error("LCOV generation script missing or coverage input missing");
      process.exit(1);
    }

    const child = spawn("node", [generateScript, inputFile, outputFile], {
      stdio: "inherit",
      cwd: process.cwd(),
      env: { ...process.env, NODE_NO_WARNINGS: "1" },
    });

    child.on("exit", (code) => process.exit(code || 0));
    child.on("error", () => process.exit(1));
    return;
  }

  // Delegate other reporters to original nyc
  const backup = __filename + ".backup";
  const dir = path.dirname(__filename);
  const alt = path.join(dir, "index.js.backup");
  
  const originalPath = fs.existsSync(backup) ? backup : fs.existsSync(alt) ? alt : null;

  if (!originalPath) {
    console.error("No original nyc backup found for reporter:", reporter);
    process.exit(1);
  }

  const child = spawn("node", [originalPath, ...args], {
    stdio: "inherit",
    cwd: process.cwd(),
    env: process.env,
  });

  child.on("exit", (code) => process.exit(code || 0));
  child.on("error", () => process.exit(1));
  return;
}

// Unknown command
console.error('Only "merge" and "report" commands are supported.');
console.error("Received:", command);
process.exit(1);
`;
    const backupPath = nycPath + '.backup';
    if (!fs.existsSync(backupPath)) {
      fs.copyFileSync(nycPath, backupPath);
    }

    fs.writeFileSync(nycPath, wrapperContent, 'utf8');
    fs.chmodSync(nycPath, '755');

    console.log(
      'Successfully created nyc wrapper for Node.js v24 compatibility',
    );
  } catch (err) {
    console.error('Error creating nyc wrapper:', err);
  }
}

fixNycCompatibility();
