# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

language: 'en-US'

early_access: false

chat:
  auto_reply: true

issue_enrichment:
  auto_enrich:
    enabled: false

# ADVISORY GUIDELINES (Guides the AI reviewer during manual reviews)
reviews:
  profile: 'assertive'
  poem: false
  request_changes_workflow: true
  high_level_summary: true
  review_status: true
  collapse_walkthrough: false
  auto_review:
    enabled: true
    drafts: false
    base_branches:
      - develop
      - develop
      - main
  path_filters:
    - '!**/docs/docs/**'
    - '!*.html'
    - '!*.md'
    - '!*.svg'
  path_instructions:
    - path: '**/*'
      instructions: |
        Conduct a comprehensive review and reevaluate all resolved and dismissed items. Include the following validation criteria:

        ## 1. Test Coverage & Quality Validation

        ### 1.1 Test File Quality
        For any modified test files, validate:
        - ✅ **Framework Compliance**: Follow Vitest and React Testing Library best practices
          - Use `vi.mock()` for mocking (not `jest.mock()`)
          - Use `describe()`, `it()`, `test()` for test structure
          - Leverage `@testing-library/react` queries (getByRole, getByText, etc.)
          - Use `@testing-library/user-event` for simulating interactions

        - ✅ **Coverage Completeness**: Cover all code paths including:
          - Success scenarios with valid data
          - Error scenarios (network failures, GraphQL errors, validation errors)
          - Edge cases (empty data, null/undefined, boundary values)
          - Loading and pending states
          - User interactions (clicks, form submissions, navigation)
          - State changes and side effects

        - ✅ **Mock Quality**:
          - GraphQL queries/mutations use `MockedProvider` or `StaticMockLink`
          - External dependencies properly mocked
          - Mock data is realistic and comprehensive
          - Cleanup performed after tests (reset mocks, clear timers)

        - ✅ **Test Structure**:
          - Tests are isolated and don't depend on execution order
          - No disabled tests (`it.skip`, `describe.skip`, `test.skip`) unless:
            - Documented with a comment explaining why
            - Linked to an issue for re-enabling
          - Proper use of `waitFor`, `act`, and async utilities

        ### 1.2 Test File Existence
        For each modified source file with logic or UI:
        - ✅ Corresponding test file exists with naming: `*.spec.tsx`, `*.spec.ts`, `*.test.tsx`, `*.test.ts`
        - ✅ Test file is colocated with component (same directory)
        - ✅ Test file is updated to reflect source changes
        - ✅ Target 100% test code coverage for new/modified code
        - ✅ **List specific line numbers** in source files lacking test coverage

        ### 1.3 Shard Compatibility
        - ✅ Tests don't break the 12-shard parallel execution strategy
        - ✅ No shared state between tests that could cause race conditions
        - ✅ Tests complete within reasonable time (testTimeout: 30000ms)

        ## 2. Code Quality & Repository Standards

        ### 2.1 TypeScript Compliance
        - ✅ **No `any` type** without explicit JSDoc justification
        - ✅ Proper interface/type definitions for:
          - Component props with `interface` declarations
          - Function parameters and return types
          - GraphQL query/mutation variables and responses
          - State and context types
        - ✅ No TypeScript errors or `@ts-ignore` comments without explanation

        ### 2.2 GraphQL Implementation
        - ✅ Queries/mutations follow patterns in `src/GraphQl/Queries/` and `src/GraphQl/Mutations/`
        - ✅ Proper typing using `gql` template tag from `graphql-tag`
        - ✅ No duplicate queries (check for pagination inconsistencies like `first`/`last` usage)
        - ✅ Error handling implemented for all GraphQL operations:
          ```typescript
          const [mutation, { loading, error }] = useMutation(MUTATION);
          // Must handle error state in UI
          ```
        - ✅ Proper use of Apollo Client hooks (`useQuery`, `useMutation`, `useSubscription`)

        ### 2.3 React & Material-UI Best Practices
        - ✅ Functional components with proper hooks usage (useState, useEffect, useMemo, useCallback)
        - ✅ Material-UI v7 component patterns followed consistently:
          - Import from `@mui/material`
          - Use emotion for styling (`@emotion/react`)
          - Follow MUI theming patterns
        - ✅ No prop drilling; use React Context or Redux when needed
        - ✅ Proper cleanup in `useEffect`:
          ```typescript
          useEffect(() => {
            // Effect logic
            return () => {
              // Cleanup subscriptions, timers, etc.
            };
          }, [deps]);
          ```

        ### 2.4 Internationalization (i18n)
        - ✅ **Zero hardcoded user-facing strings** in UI components
        - ✅ All text uses `useTranslation()` hook with translation keys:
          ```typescript
          const { t } = useTranslation('translation', { keyPrefix: 'componentName' });
          <Button>{t('buttonLabel')}</Button>
          ```
        - ✅ New translation keys added to **all locale files**:
          - `public/locales/en/translation.json`
          - `public/locales/es/translation.json`
          - `public/locales/fr/translation.json`
          - `public/locales/hi/translation.json`
          - `public/locales/zh/translation.json`
        - ✅ Keys follow nested structure matching component hierarchy

        ### 2.5 Accessibility (a11y)
        - ✅ Proper ARIA attributes where needed:
          - `aria-label` for icon-only buttons
          - `aria-describedby` for form hints and errors
          - `aria-live` for dynamic content announcements
        - ✅ Semantic HTML and proper `role` attributes
        - ✅ Keyboard navigation support (focusable elements, tab order)
        - ✅ Screen reader compatibility (meaningful text alternatives)

        ### 2.6 Package Manager
        - ✅ Use **pnpm** commands (not npm or yarn) in documentation
        - ✅ No direct `package-lock.json` or `yarn.lock` changes (use `pnpm-lock.yaml`)

        ### 2.7 Reusable Component Architecture (CRITICAL)

        **Reference**: https://docs-admin.talawa.io/docs/developer-resources/reusable-components

        #### Component Placement & Organization
        - ✅ **Admin-only components** must be in:
          - `src/components/AdminPortal/**` (components)
          - `src/types/AdminPortal/**` (types)

        - ✅ **User-only components** must be in:
          - `src/components/UserPortal/**` (components)
          - `src/types/UserPortal/**` (types)

        - ✅ **Shared components** used by both portals must be in:
          - `src/shared-components/**` (components)
          - `src/types/shared-components/**` (types)

        - ✅ **Do not** place Admin components in UserPortal or vice versa
        - ✅ **Do not** duplicate components across portals—promote to `shared-components/` if used by both
        - ✅ Portal-specific hooks belong under that portal (e.g., `AdminPortal/hooks/`)

        #### Naming Conventions
        - ✅ **Component folders and files**: PascalCase (e.g., `UserTableRow/`, `UserTableRow.tsx`)
        - ✅ **Component name must match** folder and file name exactly
        - ✅ **Test files**: `Component.spec.tsx` or `Component.test.tsx`
        - ✅ **Mock files**: `ComponentMock.ts` or `ComponentMocks.ts`
        - ✅ **Interface files**: `interface.ts` in corresponding types directory
        - ✅ Exception: `types/shared-components` folder uses kebab-case

        #### Interface & Type Definitions
        - ✅ **NO inline prop interfaces** in component files
        - ✅ All component props **must** be defined in:
          ```
          src/types/<Portal or shared-components>/<ComponentName>/interface.ts
          ```
        - ✅ Interface naming: `Interface<ComponentName>Props`
        - ✅ Single source of truth for types—import from interface.ts

        #### Import Patterns
        ```typescript
        // ✅ CORRECT: Shared component
        import { ProfileAvatarDisplay } from 'shared-components/ProfileAvatarDisplay/ProfileAvatarDisplay';
        import type { InterfaceProfileAvatarDisplayProps } from 'types/shared-components/ProfileAvatarDisplay/interface';

        // ✅ CORRECT: Admin component
        import { UserTableRow } from 'components/AdminPortal/UserTableRow/UserTableRow';
        import type { InterfaceUserTableRowProps } from 'types/AdminPortal/UserTableRow/interface';

        // ❌ WRONG: Inline interface
        interface UserTableRowProps { ... }
        ```

        #### Restricted Library Imports

        **ESLint enforces these restrictions** via `no-restricted-imports`:

        - ❌ **DataGrid**: Do not import `@mui/x-data-grid` or `@mui/x-data-grid-pro` directly
          - ✅ Use: `DataGridWrapper` from `shared-components/DataGridWrapper/`

        - ❌ **Spinner**: Do not import `Spinner` from `react-bootstrap`
          - ✅ Use: `LoadingState` from `shared-components/LoadingState/`

        - ❌ **Modal**: Do not import `Modal` from `react-bootstrap`
          - ✅ Use: `BaseModal` from `shared-components/BaseModal/`

        - ❌ **Date Pickers**: Do not import from `@mui/x-date-pickers` directly
          - ✅ Use: `DateRangePicker`, `DatePicker`, or `TimePicker` wrappers

        **Exceptions**: Direct imports are ONLY allowed in the wrapper component implementations themselves.

        #### TSDoc Requirements
        - ✅ All exported components must have JSDoc headers:
          ```typescript
          /**
          * Brief description of component purpose and usage.
          * @param props - Component props from Interface<ComponentName>Props
          * @returns JSX.Element
          */
          export const ComponentName = (props: InterfaceComponentNameProps): JSX.Element => { ... }
          ```
        - ✅ Interfaces must have JSDoc:
          ```typescript
          /**
          * Props for ComponentName component.
          */
          export interface InterfaceComponentNameProps { ... }
          ```

        #### Validation Checklist for New/Modified Components
        1. ❓ Is the component in the correct portal directory (Admin/User/shared)?
        2. ❓ Does the folder/file/component name follow PascalCase?
        3. ❓ Is there a colocated `.spec.tsx` test file?
        4. ❓ Are props defined in `src/types/.../interface.ts` (not inline)?
        5. ❓ Does the component use wrapper components instead of restricted imports?
        6. ❓ Are TSDoc comments present on component and interface?
        7. ❓ Does the import path follow the correct pattern?
        8. ❓ If shared, is it actually used by both portals? If not, move to specific portal.

        ## 3. Documentation & Code Comments

        - ✅ **JSDoc comments** (with TSDoc format) on:
          - All exported functions, classes, and interfaces
          - All components (purpose, params, returns)
          - Complex logic requiring explanation
          - GraphQL queries/mutations (parameters, return values)
        - ✅ Auto-generated documentation updated (enforced by Check-AutoDocs job)
        - ✅ README.md or feature docs updated for new features
        - ✅ Table of Contents updated (enforced by pre-commit hook)

        ## 4. Code Issues to Identify

        Report these issues with **specific line numbers**:
        - ❌ Lines of code missing test coverage
        - ❌ Unnecessary files:
          - Build artifacts (`dist/`, `build/`, `coverage/`)
          - Dependencies (`node_modules/`, `pnpm-lock.yaml` unnecessary changes)
          - Environment files (`.env`, `.env.local`)
          - IDE configs (`.vscode/`, `.idea/`)
        - ❌ Unused imports or dead code (checked by knip)
        - ❌ Debug code left in production:
          - `console.log()`, `console.debug()`, `console.info()` in non-script files
          - Commented-out code blocks
          - TODO/FIXME comments without linked issues
        - ❌ Skipped tests without documentation
        - ❌ **Inline prop interfaces** (should use interface.ts)
        - ❌ **Restricted library imports** (should use wrappers)
        - ❌ **Components in wrong portal directory**
        - ❌ **Missing TSDoc on exported components**

        ## 5. PR Requirements Validation

        ### 5.1 Issue Requirements
        - ✅ All acceptance criteria from linked issue addressed
        - ✅ No out-of-scope changes included
        - ✅ If bugs found in files being tested, they **must be fixed in this PR**
        - ✅ Bugs in unrelated files should be deferred to separate issues

        ### 5.2 Review Feedback Compliance
        - ✅ All previous review comments addressed or acknowledged
        - ✅ Requested changes implemented correctly
        - ✅ No unresolved conversations without explanation

        ### 5.3 PR Metadata
        - ✅ Clear, descriptive title following convention (e.g., "feat:", "fix:", "refactor:")
        - ✅ Linked to issue(s) using GitHub keywords (Fixes #1234, Resolves #5678)
        - ✅ Target branch is correct (typically `develop`)
        - ✅ No sensitive information exposed (checked by Check-Sensitive-Files job)

        ## 6. CI/CD Pipeline Compatibility

        - ✅ Changes won't break CI jobs:
          - Code Quality Checks (linting, formatting, type-checking)
          - Vitest test execution (12 shards)
          - Code coverage reporting
          - Documentation generation
          - Sensitive files check
          - MinIO compliance check
          - Knip unused code detection

        - ✅ Pre-commit hook requirements met:
          - `pnpm run format:fix` - Prettier formatting
          - `pnpm run lint-staged` - ESLint with zero warnings (including no-restricted-imports)
          - `pnpm run typecheck` - TypeScript compilation
          - `pnpm run update:toc` - Table of Contents
          - `pnpm run check:pom` - Page Object Model checks
          - `npx knip` - Unused file detection

        - ✅ No performance regressions in test execution time

        ## 7. Security & Best Practices

        - ✅ No security vulnerabilities introduced
        - ✅ No exposed credentials:
          - API keys, tokens, passwords
          - Database connection strings
          - Third-party service credentials
        - ✅ Proper input validation and sanitization
        - ✅ No XSS vulnerabilities in user-generated content rendering
        - ✅ Secure handling of sensitive data (PII, authentication tokens)

        ## 8. Implementation Correctness

        For files under test or modification:
        - ✅ Implementation logic is correct and bug-free
        - ✅ GraphQL queries target correct schema fields
        - ✅ Data transformations and business logic are accurate
        - ✅ Error handling covers all failure scenarios
        - ✅ State management (Redux/Context) is properly implemented
        - ✅ No race conditions or memory leaks
        - ✅ Component architecture follows reusable component policy

        ## 9. Review Decision & Approval

        ### When to Require Changes (DO NOT approve):
        - Critical bugs in implementation
        - Missing test coverage for new/modified code
        - Security vulnerabilities
        - TypeScript errors
        - Missing i18n translations
        - Accessibility violations
        - **Reusable component policy violations**:
          - Components in wrong portal directory
          - Inline prop interfaces instead of interface.ts
          - Direct imports of restricted libraries
          - Missing TSDoc on components
          - Incorrect naming conventions
        - Unaddressed review feedback
        - Out-of-scope changes without justification

        ### Approval Criteria (append `[approve]` tag ONLY when ALL are met):
        1. ✅ Complete test coverage (target 100%) with quality tests
        2. ✅ Zero code quality issues
        3. ✅ No security concerns
        4. ✅ All bugs fixed (in files being tested)
        5. ✅ Full compliance with previous feedback
        6. ✅ No unnecessary files
        7. ✅ All CI checks will pass
        8. ✅ Complete i18n support
        9. ✅ Accessibility requirements met
        10. ✅ **Reusable component policy fully followed**
        11. ✅ **Zero changes needed** - even minor improvements should block approval

        **Important**: Be strict with approvals. If you suggest any improvement, do not approve.

        ## 10. Focus & Prioritization

        - **Prioritize substantive issues** over stylistic preferences
        - **Focus on CI-breaking issues** and production bugs first
        - **Component architecture violations** are high priority (affects maintainability)
        - **Highlight pattern deviations** that could cause maintenance issues
        - **Be specific**: Provide exact line numbers, not just file names
        - **Be constructive**: Suggest concrete solutions with correct paths/patterns

        ## 11. Scope Boundaries

        - Test-focused PRs should maintain clear scope boundaries
        - Bugs in the **specific files being tested MUST be fixed** in the same PR
        - Bugs in **unrelated files** should be deferred to separate issues
        - **Component refactoring for policy compliance** should be scoped appropriately:
          - If adding a new component, it must follow the policy
          - If significantly modifying an existing component, consider refactoring to policy
          - Bulk refactoring of existing components should be separate PRs
        - Document scope decisions clearly in review comments

  # ENFORCED VALIDATION GATES (blocks PRs programmatically)
  pre_merge_checks:
    # Enforce test file updates for modified source files
    custom_checks:
      - name: 'Test Coverage Validation'
        mode: 'error' # Blocks PR until resolved
        instructions: |
          Conduct a comprehensive review and reevaluate all resolved and dismissed items. Include the following validation criteria:

          ## 1. Test Coverage & Quality Validation

          ### 1.1 Test File Quality
          For any modified test files, validate:
          - ✅ **Framework Compliance**: Follow Vitest and React Testing Library best practices
            - Use `vi.mock()` for mocking (not `jest.mock()`)
            - Use `describe()`, `it()`, `test()` for test structure
            - Leverage `@testing-library/react` queries (getByRole, getByText, etc.)
            - Use `@testing-library/user-event` for simulating interactions

          - ✅ **Coverage Completeness**: Cover all code paths including:
            - Success scenarios with valid data
            - Error scenarios (network failures, GraphQL errors, validation errors)
            - Edge cases (empty data, null/undefined, boundary values)
            - Loading and pending states
            - User interactions (clicks, form submissions, navigation)
            - State changes and side effects

          - ✅ **Mock Quality**:
            - GraphQL queries/mutations use `MockedProvider` or `StaticMockLink`
            - External dependencies properly mocked
            - Mock data is realistic and comprehensive
            - Cleanup performed after tests (reset mocks, clear timers)

          - ✅ **Test Structure**:
            - Tests are isolated and don't depend on execution order
            - No disabled tests (`it.skip`, `describe.skip`, `test.skip`) unless:
              - Documented with a comment explaining why
              - Linked to an issue for re-enabling
            - Proper use of `waitFor`, `act`, and async utilities

          ### 1.2 Test File Existence
          For each modified source file with logic or UI:
          - ✅ Corresponding test file exists with naming: `*.spec.tsx`, `*.spec.ts`, `*.test.tsx`, `*.test.ts`
          - ✅ Test file is colocated with component (same directory)
          - ✅ Test file is updated to reflect source changes
          - ✅ Target 100% test code coverage for new/modified code
          - ✅ **List specific line numbers** in source files lacking test coverage

          ### 1.3 Shard Compatibility
          - ✅ Tests don't break the 12-shard parallel execution strategy
          - ✅ No shared state between tests that could cause race conditions
          - ✅ Tests complete within reasonable time (testTimeout: 30000ms)

          ## 2. Code Quality & Repository Standards

          ### 2.1 TypeScript Compliance
          - ✅ **No `any` type** without explicit JSDoc justification
          - ✅ Proper interface/type definitions for:
            - Component props with `interface` declarations
            - Function parameters and return types
            - GraphQL query/mutation variables and responses
            - State and context types
          - ✅ No TypeScript errors or `@ts-ignore` comments without explanation

          ### 2.2 GraphQL Implementation
          - ✅ Queries/mutations follow patterns in `src/GraphQl/Queries/` and `src/GraphQl/Mutations/`
          - ✅ Proper typing using `gql` template tag from `graphql-tag`
          - ✅ No duplicate queries (check for pagination inconsistencies like `first`/`last` usage)
          - ✅ Error handling implemented for all GraphQL operations:
            ```typescript
            const [mutation, { loading, error }] = useMutation(MUTATION);
            // Must handle error state in UI
            ```
          - ✅ Proper use of Apollo Client hooks (`useQuery`, `useMutation`, `useSubscription`)

          ### 2.3 React & Material-UI Best Practices
          - ✅ Functional components with proper hooks usage (useState, useEffect, useMemo, useCallback)
          - ✅ Material-UI v7 component patterns followed consistently:
            - Import from `@mui/material`
            - Use emotion for styling (`@emotion/react`)
            - Follow MUI theming patterns
          - ✅ No prop drilling; use React Context or Redux when needed
          - ✅ Proper cleanup in `useEffect`:
            ```typescript
            useEffect(() => {
              // Effect logic
              return () => {
                // Cleanup subscriptions, timers, etc.
              };
            }, [deps]);
            ```

          ### 2.4 Internationalization (i18n)
          - ✅ **Zero hardcoded user-facing strings** in UI components
          - ✅ All text uses `useTranslation()` hook with translation keys:
            ```typescript
            const { t } = useTranslation('translation', { keyPrefix: 'componentName' });
            <Button>{t('buttonLabel')}</Button>
            ```
          - ✅ New translation keys added to **all locale files**:
            - `public/locales/en/translation.json`
            - `public/locales/es/translation.json`
            - `public/locales/fr/translation.json`
            - `public/locales/hi/translation.json`
            - `public/locales/zh/translation.json`
          - ✅ Keys follow nested structure matching component hierarchy

          ### 2.5 Accessibility (a11y)
          - ✅ Proper ARIA attributes where needed:
            - `aria-label` for icon-only buttons
            - `aria-describedby` for form hints and errors
            - `aria-live` for dynamic content announcements
          - ✅ Semantic HTML and proper `role` attributes
          - ✅ Keyboard navigation support (focusable elements, tab order)
          - ✅ Screen reader compatibility (meaningful text alternatives)

          ### 2.6 Package Manager
          - ✅ Use **pnpm** commands (not npm or yarn) in documentation
          - ✅ No direct `package-lock.json` or `yarn.lock` changes (use `pnpm-lock.yaml`)

          ### 2.7 Reusable Component Architecture (CRITICAL)

          **Reference**: https://docs-admin.talawa.io/docs/developer-resources/reusable-components

          #### Component Placement & Organization
          - ✅ **Admin-only components** must be in:
            - `src/components/AdminPortal/**` (components)
            - `src/types/AdminPortal/**` (types)

          - ✅ **User-only components** must be in:
            - `src/components/UserPortal/**` (components)
            - `src/types/UserPortal/**` (types)

          - ✅ **Shared components** used by both portals must be in:
            - `src/shared-components/**` (components)
            - `src/types/shared-components/**` (types)

          - ✅ **Do not** place Admin components in UserPortal or vice versa
          - ✅ **Do not** duplicate components across portals—promote to `shared-components/` if used by both
          - ✅ Portal-specific hooks belong under that portal (e.g., `AdminPortal/hooks/`)

          #### Naming Conventions
          - ✅ **Component folders and files**: PascalCase (e.g., `UserTableRow/`, `UserTableRow.tsx`)
          - ✅ **Component name must match** folder and file name exactly
          - ✅ **Test files**: `Component.spec.tsx` or `Component.test.tsx`
          - ✅ **Mock files**: `ComponentMock.ts` or `ComponentMocks.ts`
          - ✅ **Interface files**: `interface.ts` in corresponding types directory
          - ✅ Exception: `types/shared-components` folder uses kebab-case

          #### Interface & Type Definitions
          - ✅ **NO inline prop interfaces** in component files
          - ✅ All component props **must** be defined in:
            ```
            src/types/<Portal or shared-components>/<ComponentName>/interface.ts
            ```
          - ✅ Interface naming: `Interface<ComponentName>Props`
          - ✅ Single source of truth for types—import from interface.ts

          #### Import Patterns
          ```typescript
          // ✅ CORRECT: Shared component
          import { ProfileAvatarDisplay } from 'shared-components/ProfileAvatarDisplay/ProfileAvatarDisplay';
          import type { InterfaceProfileAvatarDisplayProps } from 'types/shared-components/ProfileAvatarDisplay/interface';

          // ✅ CORRECT: Admin component
          import { UserTableRow } from 'components/AdminPortal/UserTableRow/UserTableRow';
          import type { InterfaceUserTableRowProps } from 'types/AdminPortal/UserTableRow/interface';

          // ❌ WRONG: Inline interface
          interface UserTableRowProps { ... }
          ```

          #### Restricted Library Imports

          **ESLint enforces these restrictions** via `no-restricted-imports`:

          - ❌ **DataGrid**: Do not import `@mui/x-data-grid` or `@mui/x-data-grid-pro` directly
            - ✅ Use: `DataGridWrapper` from `shared-components/DataGridWrapper/`

          - ❌ **Spinner**: Do not import `Spinner` from `react-bootstrap`
            - ✅ Use: `LoadingState` from `shared-components/LoadingState/`

          - ❌ **Modal**: Do not import `Modal` from `react-bootstrap`
            - ✅ Use: `BaseModal` from `shared-components/BaseModal/`

          - ❌ **Date Pickers**: Do not import from `@mui/x-date-pickers` directly
            - ✅ Use: `DateRangePicker`, `DatePicker`, or `TimePicker` wrappers

          **Exceptions**: Direct imports are ONLY allowed in the wrapper component implementations themselves.

          #### TSDoc Requirements
          - ✅ All exported components must have JSDoc headers:
            ```typescript
            /**
            * Brief description of component purpose and usage.
            * @param props - Component props from Interface<ComponentName>Props
            * @returns JSX.Element
            */
            export const ComponentName = (props: InterfaceComponentNameProps): JSX.Element => { ... }
            ```
          - ✅ Interfaces must have JSDoc:
            ```typescript
            /**
            * Props for ComponentName component.
            */
            export interface InterfaceComponentNameProps { ... }
            ```

          #### Validation Checklist for New/Modified Components
          1. ❓ Is the component in the correct portal directory (Admin/User/shared)?
          2. ❓ Does the folder/file/component name follow PascalCase?
          3. ❓ Is there a colocated `.spec.tsx` test file?
          4. ❓ Are props defined in `src/types/.../interface.ts` (not inline)?
          5. ❓ Does the component use wrapper components instead of restricted imports?
          6. ❓ Are TSDoc comments present on component and interface?
          7. ❓ Does the import path follow the correct pattern?
          8. ❓ If shared, is it actually used by both portals? If not, move to specific portal.

          ## 3. Documentation & Code Comments

          - ✅ **JSDoc comments** (with TSDoc format) on:
            - All exported functions, classes, and interfaces
            - All components (purpose, params, returns)
            - Complex logic requiring explanation
            - GraphQL queries/mutations (parameters, return values)
          - ✅ Auto-generated documentation updated (enforced by Check-AutoDocs job)
          - ✅ README.md or feature docs updated for new features
          - ✅ Table of Contents updated (enforced by pre-commit hook)

          ## 4. Code Issues to Identify

          Report these issues with **specific line numbers**:
          - ❌ Lines of code missing test coverage
          - ❌ Unnecessary files:
            - Build artifacts (`dist/`, `build/`, `coverage/`)
            - Dependencies (`node_modules/`, `pnpm-lock.yaml` unnecessary changes)
            - Environment files (`.env`, `.env.local`)
            - IDE configs (`.vscode/`, `.idea/`)
          - ❌ Unused imports or dead code (checked by knip)
          - ❌ Debug code left in production:
            - `console.log()`, `console.debug()`, `console.info()` in non-script files
            - Commented-out code blocks
            - TODO/FIXME comments without linked issues
          - ❌ Skipped tests without documentation
          - ❌ **Inline prop interfaces** (should use interface.ts)
          - ❌ **Restricted library imports** (should use wrappers)
          - ❌ **Components in wrong portal directory**
          - ❌ **Missing TSDoc on exported components**

          ## 5. PR Requirements Validation

          ### 5.1 Issue Requirements
          - ✅ All acceptance criteria from linked issue addressed
          - ✅ No out-of-scope changes included
          - ✅ If bugs found in files being tested, they **must be fixed in this PR**
          - ✅ Bugs in unrelated files should be deferred to separate issues

          ### 5.2 Review Feedback Compliance
          - ✅ All previous review comments addressed or acknowledged
          - ✅ Requested changes implemented correctly
          - ✅ No unresolved conversations without explanation

          ### 5.3 PR Metadata
          - ✅ Clear, descriptive title following convention (e.g., "feat:", "fix:", "refactor:")
          - ✅ Linked to issue(s) using GitHub keywords (Fixes #1234, Resolves #5678)
          - ✅ Target branch is correct (typically `develop`)
          - ✅ No sensitive information exposed (checked by Check-Sensitive-Files job)

          ## 6. CI/CD Pipeline Compatibility

          - ✅ Changes won't break CI jobs:
            - Code Quality Checks (linting, formatting, type-checking)
            - Vitest test execution (12 shards)
            - Code coverage reporting
            - Documentation generation
            - Sensitive files check
            - MinIO compliance check
            - Knip unused code detection

          - ✅ Pre-commit hook requirements met:
            - `pnpm run format:fix` - Prettier formatting
            - `pnpm run lint-staged` - ESLint with zero warnings (including no-restricted-imports)
            - `pnpm run typecheck` - TypeScript compilation
            - `pnpm run update:toc` - Table of Contents
            - `pnpm run check:pom` - Page Object Model checks
            - `npx knip` - Unused file detection

          - ✅ No performance regressions in test execution time

          ## 7. Security & Best Practices

          - ✅ No security vulnerabilities introduced
          - ✅ No exposed credentials:
            - API keys, tokens, passwords
            - Database connection strings
            - Third-party service credentials
          - ✅ Proper input validation and sanitization
          - ✅ No XSS vulnerabilities in user-generated content rendering
          - ✅ Secure handling of sensitive data (PII, authentication tokens)

          ## 8. Implementation Correctness

          For files under test or modification:
          - ✅ Implementation logic is correct and bug-free
          - ✅ GraphQL queries target correct schema fields
          - ✅ Data transformations and business logic are accurate
          - ✅ Error handling covers all failure scenarios
          - ✅ State management (Redux/Context) is properly implemented
          - ✅ No race conditions or memory leaks
          - ✅ Component architecture follows reusable component policy

          ## 9. Review Decision & Approval

          ### When to Require Changes (DO NOT approve):
          - Critical bugs in implementation
          - Missing test coverage for new/modified code
          - Security vulnerabilities
          - TypeScript errors
          - Missing i18n translations
          - Accessibility violations
          - **Reusable component policy violations**:
            - Components in wrong portal directory
            - Inline prop interfaces instead of interface.ts
            - Direct imports of restricted libraries
            - Missing TSDoc on components
            - Incorrect naming conventions
          - Unaddressed review feedback
          - Out-of-scope changes without justification

          ### Approval Criteria (append `[approve]` tag ONLY when ALL are met):
          1. ✅ Complete test coverage (target 100%) with quality tests
          2. ✅ Zero code quality issues
          3. ✅ No security concerns
          4. ✅ All bugs fixed (in files being tested)
          5. ✅ Full compliance with previous feedback
          6. ✅ No unnecessary files
          7. ✅ All CI checks will pass
          8. ✅ Complete i18n support
          9. ✅ Accessibility requirements met
          10. ✅ **Reusable component policy fully followed**
          11. ✅ **Zero changes needed** - even minor improvements should block approval

          **Important**: Be strict with approvals. If you suggest any improvement, do not approve.

          ## 10. Focus & Prioritization

          - **Prioritize substantive issues** over stylistic preferences
          - **Focus on CI-breaking issues** and production bugs first
          - **Component architecture violations** are high priority (affects maintainability)
          - **Highlight pattern deviations** that could cause maintenance issues
          - **Be specific**: Provide exact line numbers, not just file names
          - **Be constructive**: Suggest concrete solutions with correct paths/patterns

          ## 11. Scope Boundaries

          - Test-focused PRs should maintain clear scope boundaries
          - Bugs in the **specific files being tested MUST be fixed** in the same PR
          - Bugs in **unrelated files** should be deferred to separate issues
          - **Component refactoring for policy compliance** should be scoped appropriately:
            - If adding a new component, it must follow the policy
            - If significantly modifying an existing component, consider refactoring to policy
            - Bulk refactoring of existing components should be separate PRs
          - Document scope decisions clearly in review comments
