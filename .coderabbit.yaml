# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

language: 'en-US'

early_access: false

chat:
  auto_reply: true

issue_enrichment:
  auto_enrich:
    enabled: false

# ADVISORY GUIDELINES (Guides the AI reviewer during manual reviews)
reviews:
  profile: 'assertive'
  poem: false
  request_changes_workflow: true
  high_level_summary: true
  review_status: true
  collapse_walkthrough: false
  auto_review:
    enabled: true
    drafts: false
    base_branches:
      - develop
      - develop
      - main
  path_filters:
    - '!**/docs/docs/**'
    - '!*.html'
    - '!*.md'
    - '!*.svg'
  path_instructions:
    - path: '**/*'
      instructions: |
        Conduct a comprehensive review and reevaluate all resolved and dismissed items. Include the following validation criteria:

        ## 1. Test Coverage & Quality Validation

        ### 1.1 Test File Quality
        For any modified test files, validate:
        - ✅ **Framework Compliance**: Follow Vitest and React Testing Library best practices
          - Use `vi.mock()` for mocking (not `jest.mock()`)
          - Use `describe()`, `it()`, `test()` for test structure
          - Leverage `@testing-library/react` queries (getByRole, getByText, etc.)
          - Use `@testing-library/user-event` for simulating interactions

        - ✅ **Coverage Completeness**: Cover all code paths including:
          - Success scenarios with valid data
          - Error scenarios (network failures, GraphQL errors, validation errors)
          - Edge cases (empty data, null/undefined, boundary values)
          - Loading and pending states
          - User interactions (clicks, form submissions, navigation)
          - State changes and side effects

        - ✅ **Mock Quality**:
          - GraphQL queries/mutations use `MockedProvider` or `StaticMockLink`
          - External dependencies properly mocked
          - Mock data is realistic and comprehensive
          - Cleanup performed after tests (reset mocks, clear timers)

        - ✅ **Test Structure**:
          - Tests are isolated and don't depend on execution order
          - No disabled tests (`it.skip`, `describe.skip`, `test.skip`) unless:
            - Documented with a comment explaining why
            - Linked to an issue for re-enabling
          - Proper use of `waitFor`, `act`, and async utilities

        ### 1.2 Test File Existence
        For each modified source file with logic or UI:
        - ✅ Corresponding test file exists with naming: `*.spec.tsx`, `*.spec.ts`, `*.test.tsx`, `*.test.ts`
        - ✅ Test file is colocated with component (same directory)
        - ✅ Test file is updated to reflect source changes
        - ✅ Target 100% test code coverage for new/modified code
        - ✅ **List specific line numbers** in source files lacking test coverage

        ### 1.3 Shard Compatibility
        - ✅ Tests don't break the 12-shard parallel execution strategy
        - ✅ No shared state between tests that could cause race conditions
        - ✅ Tests complete within reasonable time (testTimeout: 30000ms)

        ## 2. Code Quality & Repository Standards

        ### 2.1 TypeScript Compliance
        - ✅ **No `any` type** without explicit JSDoc justification
        - ✅ Proper interface/type definitions for:
          - Component props with `interface` declarations
          - Function parameters and return types
          - GraphQL query/mutation variables and responses
          - State and context types
        - ✅ No TypeScript errors or `@ts-ignore` comments without explanation

        ### 2.2 GraphQL Implementation
        - ✅ Queries/mutations follow patterns in `src/GraphQl/Queries/` and `src/GraphQl/Mutations/`
        - ✅ Proper typing using `gql` template tag from `graphql-tag`
        - ✅ No duplicate queries (check for pagination inconsistencies like `first`/`last` usage)
        - ✅ Error handling implemented for all GraphQL operations:
          ```typescript
          const [mutation, { loading, error }] = useMutation(MUTATION);
          // Must handle error state in UI
          ```
        - ✅ Proper use of Apollo Client hooks (`useQuery`, `useMutation`, `useSubscription`)

        ### 2.3 React & Material-UI Best Practices
        - ✅ Functional components with proper hooks usage (useState, useEffect, useMemo, useCallback)
        - ✅ Material-UI v7 component patterns followed consistently:
          - Import from `@mui/material`
          - Use emotion for styling (`@emotion/react`)
          - Follow MUI theming patterns
        - ✅ No prop drilling; use React Context or Redux when needed
        - ✅ Proper cleanup in `useEffect`:
          ```typescript
          useEffect(() => {
            // Effect logic
            return () => {
              // Cleanup subscriptions, timers, etc.
            };
          }, [deps]);
          ```

        ### 2.4 Internationalization (i18n)
        - ✅ **Zero hardcoded user-facing strings** in UI components
        - ✅ All text uses `useTranslation()` hook with translation keys:
          ```typescript
          const { t } = useTranslation('translation', { keyPrefix: 'componentName' });
          <Button>{t('buttonLabel')}</Button>
          ```
        - ✅ New translation keys added to **all locale files**:
          - `public/locales/en/translation.json`
          - `public/locales/es/translation.json`
          - `public/locales/fr/translation.json`
          - `public/locales/hi/translation.json`
          - `public/locales/zh/translation.json`
        - ✅ Keys follow nested structure matching component hierarchy

        ### 2.5 Accessibility (a11y)
        - ✅ Proper ARIA attributes where needed:
          - `aria-label` for icon-only buttons
          - `aria-describedby` for form hints and errors
          - `aria-live` for dynamic content announcements
        - ✅ Semantic HTML and proper `role` attributes
        - ✅ Keyboard navigation support (focusable elements, tab order)
        - ✅ Screen reader compatibility (meaningful text alternatives)

        ### 2.6 Package Manager
        - ✅ Use **pnpm** commands (not npm or yarn) in documentation
        - ✅ No direct `package-lock.json` or `yarn.lock` changes (use `pnpm-lock.yaml`)

        ### 2.7 Reusable Component Architecture (CRITICAL)

        **Reference**: https://docs-admin.talawa.io/docs/developer-resources/reusable-components

        #### Component Placement & Organization
        - ✅ **Admin-only components** must be in:
          - `src/components/AdminPortal/**` (components)
          - `src/types/AdminPortal/**` (types)

        - ✅ **User-only components** must be in:
          - `src/components/UserPortal/**` (components)
          - `src/types/UserPortal/**` (types)

        - ✅ **Shared components** used by both portals must be in:
          - `src/shared-components/**` (components)
          - `src/types/shared-components/**` (types)

        - ✅ **Do not** place Admin components in UserPortal or vice versa
        - ✅ **Do not** duplicate components across portals—promote to `shared-components/` if used by both
        - ✅ Portal-specific hooks belong under that portal (e.g., `AdminPortal/hooks/`)

        #### Naming Conventions
        - ✅ **Component folders and files**: PascalCase (e.g., `UserTableRow/`, `UserTableRow.tsx`)
        - ✅ **Component name must match** folder and file name exactly
        - ✅ **Test files**: `Component.spec.tsx` or `Component.test.tsx`
        - ✅ **Mock files**: `ComponentMock.ts` or `ComponentMocks.ts`
        - ✅ **Interface files**: `interface.ts` in corresponding types directory
        - ✅ Exception: `types/shared-components` folder uses kebab-case

        #### Interface & Type Definitions
        - ✅ **NO inline prop interfaces** in component files
        - ✅ All component props **must** be defined in:
          ```
          src/types/<Portal or shared-components>/<ComponentName>/interface.ts
          ```
        - ✅ Interface naming: `Interface<ComponentName>Props`
        - ✅ Single source of truth for types—import from interface.ts

        #### Import Patterns
        ```typescript
        // ✅ CORRECT: Shared component
        import { ProfileAvatarDisplay } from 'shared-components/ProfileAvatarDisplay/ProfileAvatarDisplay';
        import type { InterfaceProfileAvatarDisplayProps } from 'types/shared-components/ProfileAvatarDisplay/interface';

        // ✅ CORRECT: Admin component
        import { UserTableRow } from 'components/AdminPortal/UserTableRow/UserTableRow';
        import type { InterfaceUserTableRowProps } from 'types/AdminPortal/UserTableRow/interface';

        // ❌ WRONG: Inline interface
        interface UserTableRowProps { ... }
        ```

        #### Restricted Library Imports

        **ESLint enforces these restrictions** via `no-restricted-imports`:

        - ❌ **DataGrid**: Do not import `@mui/x-data-grid` or `@mui/x-data-grid-pro` directly
          - ✅ Use: `DataGridWrapper` from `shared-components/DataGridWrapper/`

        - ❌ **Spinner**: Do not import `Spinner` from `react-bootstrap`
          - ✅ Use: `LoadingState` from `shared-components/LoadingState/`

        - ❌ **Modal**: Do not import `Modal` from `react-bootstrap`
          - ✅ Use: `BaseModal` from `shared-components/BaseModal/`

        - ❌ **Date Pickers**: Do not import from `@mui/x-date-pickers` directly
          - ✅ Use: `DateRangePicker`, `DatePicker`, or `TimePicker` wrappers

        **Exceptions**: Direct imports are ONLY allowed in the wrapper component implementations themselves.

        #### TSDoc Requirements
        - ✅ All exported components must have JSDoc headers:
          ```typescript
          /**
          * Brief description of component purpose and usage.
          * @param props - Component props from Interface<ComponentName>Props
          * @returns JSX.Element
          */
          export const ComponentName = (props: InterfaceComponentNameProps): JSX.Element => { ... }
          ```
        - ✅ Interfaces must have JSDoc:
          ```typescript
          /**
          * Props for ComponentName component.
          */
          export interface InterfaceComponentNameProps { ... }
          ```

        #### Validation Checklist for New/Modified Components
        1. ❓ Is the component in the correct portal directory (Admin/User/shared)?
        2. ❓ Does the folder/file/component name follow PascalCase?
        3. ❓ Is there a colocated `.spec.tsx` test file?
        4. ❓ Are props defined in `src/types/.../interface.ts` (not inline)?
        5. ❓ Does the component use wrapper components instead of restricted imports?
        6. ❓ Are TSDoc comments present on component and interface?
        7. ❓ Does the import path follow the correct pattern?
        8. ❓ If shared, is it actually used by both portals? If not, move to specific portal.

        ## 3. Documentation & Code Comments

        - ✅ **JSDoc comments** (with TSDoc format) on:
          - All exported functions, classes, and interfaces
          - All components (purpose, params, returns)
          - Complex logic requiring explanation
          - GraphQL queries/mutations (parameters, return values)
        - ✅ Auto-generated documentation updated (enforced by Check-AutoDocs job)
        - ✅ README.md or feature docs updated for new features
        - ✅ Table of Contents updated (enforced by pre-commit hook)

        ## 4. Code Issues to Identify

        Report these issues with **specific line numbers**:
        - ❌ Lines of code missing test coverage
        - ❌ Unnecessary files:
          - Build artifacts (`dist/`, `build/`, `coverage/`)
          - Dependencies (`node_modules/`, `pnpm-lock.yaml` unnecessary changes)
          - Environment files (`.env`, `.env.local`)
          - IDE configs (`.vscode/`, `.idea/`)
        - ❌ Unused imports or dead code (checked by knip)
        - ❌ Debug code left in production:
          - `console.log()`, `console.debug()`, `console.info()` in non-script files
          - Commented-out code blocks
          - TODO/FIXME comments without linked issues
        - ❌ Skipped tests without documentation
        - ❌ **Inline prop interfaces** (should use interface.ts)
        - ❌ **Restricted library imports** (should use wrappers)
        - ❌ **Components in wrong portal directory**
        - ❌ **Missing TSDoc on exported components**

        ## 5. PR Requirements Validation

        ### 5.1 Issue Requirements
        - ✅ All acceptance criteria from linked issue addressed
        - ✅ No out-of-scope changes included
        - ✅ If bugs found in files being tested, they **must be fixed in this PR**
        - ✅ Bugs in unrelated files should be deferred to separate issues

        ### 5.2 Review Feedback Compliance
        - ✅ All previous review comments addressed or acknowledged
        - ✅ Requested changes implemented correctly
        - ✅ No unresolved conversations without explanation

        ### 5.3 PR Metadata
        - ✅ Clear, descriptive title following convention (e.g., "feat:", "fix:", "refactor:")
        - ✅ Linked to issue(s) using GitHub keywords (Fixes #1234, Resolves #5678)
        - ✅ Target branch is correct (typically `develop`)
        - ✅ No sensitive information exposed (checked by Check-Sensitive-Files job)

        ## 6. CI/CD Pipeline Compatibility

        - ✅ Changes won't break CI jobs:
          - Code Quality Checks (linting, formatting, type-checking)
          - Vitest test execution (12 shards)
          - Code coverage reporting
          - Documentation generation
          - Sensitive files check
          - MinIO compliance check
          - Knip unused code detection

        - ✅ Pre-commit hook requirements met:
          - `pnpm run format:fix` - Prettier formatting
          - `pnpm run lint-staged` - ESLint with zero warnings (including no-restricted-imports)
          - `pnpm run typecheck` - TypeScript compilation
          - `pnpm run update:toc` - Table of Contents
          - `pnpm run check:pom` - Page Object Model checks
          - `npx knip` - Unused file detection

        - ✅ No performance regressions in test execution time

        ## 7. Security & Best Practices

        - ✅ No security vulnerabilities introduced
        - ✅ No exposed credentials:
          - API keys, tokens, passwords
          - Database connection strings
          - Third-party service credentials
        - ✅ Proper input validation and sanitization
        - ✅ No XSS vulnerabilities in user-generated content rendering
        - ✅ Secure handling of sensitive data (PII, authentication tokens)

        ## 8. Implementation Correctness

        For files under test or modification:
        - ✅ Implementation logic is correct and bug-free
        - ✅ GraphQL queries target correct schema fields
        - ✅ Data transformations and business logic are accurate
        - ✅ Error handling covers all failure scenarios
        - ✅ State management (Redux/Context) is properly implemented
        - ✅ No race conditions or memory leaks
        - ✅ Component architecture follows reusable component policy

        ## 9. Review Decision & Approval

        ### When to Require Changes (DO NOT approve):
        - Critical bugs in implementation
        - Missing test coverage for new/modified code
        - Security vulnerabilities
        - TypeScript errors
        - Missing i18n translations
        - Accessibility violations
        - **Reusable component policy violations**:
          - Components in wrong portal directory
          - Inline prop interfaces instead of interface.ts
          - Direct imports of restricted libraries
          - Missing TSDoc on components
          - Incorrect naming conventions
        - Unaddressed review feedback
        - Out-of-scope changes without justification

        ### Approval Criteria (append `[approve]` tag ONLY when ALL are met):
        1. ✅ Complete test coverage (target 100%) with quality tests
        2. ✅ Zero code quality issues
        3. ✅ No security concerns
        4. ✅ All bugs fixed (in files being tested)
        5. ✅ Full compliance with previous feedback
        6. ✅ No unnecessary files
        7. ✅ All CI checks will pass
        8. ✅ Complete i18n support
        9. ✅ Accessibility requirements met
        10. ✅ **Reusable component policy fully followed**
        11. ✅ **Zero changes needed** - even minor improvements should block approval

        **Important**: Be strict with approvals. If you suggest any improvement, do not approve.

        ## 10. Focus & Prioritization

        - **Prioritize substantive issues** over stylistic preferences
        - **Focus on CI-breaking issues** and production bugs first
        - **Component architecture violations** are high priority (affects maintainability)
        - **Highlight pattern deviations** that could cause maintenance issues
        - **Be specific**: Provide exact line numbers, not just file names
        - **Be constructive**: Suggest concrete solutions with correct paths/patterns

        ## 11. Scope Boundaries

        - Test-focused PRs should maintain clear scope boundaries
        - Bugs in the **specific files being tested MUST be fixed** in the same PR
        - Bugs in **unrelated files** should be deferred to separate issues
        - **Component refactoring for policy compliance** should be scoped appropriately:
          - If adding a new component, it must follow the policy
          - If significantly modifying an existing component, consider refactoring to policy
          - Bulk refactoring of existing components should be separate PRs
        - Document scope decisions clearly in review comments

  # ENFORCED VALIDATION GATES (blocks PRs programmatically)
  pre_merge_checks:
    # Enforce test file updates for modified source files
    custom_checks:
      - name: 'Test Coverage Validation'
        mode: 'error' # Blocks PR until resolved
        instructions: |
          Full review and reevaluate all resolved items and include the following points:

          1. **Test Coverage & Quality Validation:**
              1. Validate whether any updated test files:
                  1. Cover all use cases including edge cases, error scenarios, and success paths
                  2. Have valid, properly structured tests following Jest and React Testing Library best practices
                  3. Provide 100% test code coverage for all modified/added functions, components, and branches
                  4. Include proper mocking of GraphQL queries/mutations, external dependencies, and API calls
                  5. Test both user interactions and state changes comprehensively
                  6. Require any additional tests for uncovered scenarios
              1. For each modified file with logic or UI, verify corresponding test files exist and are updated:
                  1. Check that test files follow naming conventions (_.test.tsx, _.test.ts, _.spec.tsx, _.spec.ts)
                  1. Validate that tests don't include disabled tests (it.skip, describe.skip) unless explicitly documented
                  1. Ensure mock data cleanup is performed (as required by pre-commit hooks)

          1. **Code Quality & Repository Standards:**
              1. Verify TypeScript compliance:
                  1. No use of `any` type without explicit justification
                  2. Proper interface/type definitions for all props, state, and function parameters
                  3. No TypeScript errors or warnings
              1. Validate GraphQL implementation:
                  1. Queries/mutations are properly typed and follow existing patterns in src/GraphQl/
                  2. No duplicate or redundant queries (check for pagination inconsistencies)
                  3. Error handling is implemented for all GraphQL operations
              1. Check React component best practices:
                  1. Functional components with proper hooks usage
                  2. Material-UI component patterns are followed consistently
                  3. No prop drilling; proper use of context when needed
                  4. Proper cleanup in useEffect hooks
              1. Verify internationalization (i18n):
                  1. All user-facing strings use i18next translation keys
                  2. New translation keys are added to locale files
                  3. No hardcoded English text in UI components
              1. Validate accessibility:
                  1. Proper ARIA labels and roles
                  2. Keyboard navigation support
                  3. Screen reader compatibility

          1. **Documentation & Code Comments:**
              1. Verify auto-generated documentation is updated (as enforced by Check-AutoDocs job)
              2. Check for adequate JSDoc comments on public functions and complex logic
              3. Ensure README.md or related docs are updated if new features are added
              4. Validate that Table of Contents is updated (as required by pre-commit hooks)

          1. **Identify Issues:**
              1. Lines of code that are missing tests (list specific line numbers)
              2. Any unnecessary files that have been submitted (build artifacts, node_modules, .env files, IDE configs)
              3. Unused imports or dead code (as checked by knip)
              4. Console.log statements or debug code left in production files
              5. Files that should be excluded from the PR scope

          1. **PR Requirements Validation:**
              1. Verify the PR meets the requirements of the linked issue:
                  1. All acceptance criteria are addressed
                  2. No out-of-scope changes are included
              2. Validate compliance with all previously suggested improvements and comments:
                  1. All review comments have been addressed
                  2. Requested changes have been implemented correctly
              3. Check PR metadata:
                  1. Proper title and description
                  2. Linked to appropriate issue(s)
                  3. Target branch is correct (typically `develop`)
              4. Verify no sensitive information is exposed (as checked by Check-Sensitive-Files job)

          1. **CI/CD Pipeline Compatibility:**
              1. Validate that code changes won't break any of the 17+ CI jobs
              2. Ensure pre-commit hook requirements are met:
                  1. Code formatting (Prettier)
                  2. Linting (ESLint)
                  3. Type checking (TypeScript)
              3. Check that changes don't introduce performance regressions for the 12-shard test execution

          1. **Security & Best Practices:**
              1. No security vulnerabilities introduced
              2. No exposed API keys, tokens, or credentials
              3. Proper input validation and sanitization
              4. No SQL injection or XSS vulnerabilities in any data handling

          1. **Implementation Correctness:**
              1. For the specific implementation file(s) being tested:
                  1. Verify the implementation logic is correct and free of bugs
                  1. Validate that queries target the correct database tables/entities
                  1. Check that foreign key relationships are correctly enforced
                  1. Confirm business logic constraints are properly implemented
                  1. Any bugs, logic errors, or incorrect implementations discovered in the file(s) under test MUST be fixed in this PR before approval

          1. **Review Decision:**
              1. When critical issues are found, clearly state that changes are required in your response but DO NOT append the [approve] tag.
              1. Only append the [approve] tag when ALL criteria are satisfied and zero changes are required:
                  1. Complete test coverage (≥95%)
                  2. No code quality issues, security concerns, or bugs
                  3. Full implementation of issue requirements
                  4. No bugs or logic errors in the implementation file(s) under test
                  5. Compliance with all previous feedback
                  6. No unnecessary files

          1. **Approvals:**
              1. Approve the PR by appending the text "APPROVED" below your response only if:
              2. All criteria above are fully satisfied
              3. The implementation file(s) under test are correct and bug-free
              4. No changes, even trivial ones, are required

          1. **Focus Areas:**
              1. Prioritize substantive issues over minor stylistic suggestions
              2. Focus on issues that would cause CI pipeline failures or production bugs
              3. Highlight any deviations from established codebase patterns

          **Note:** Test-focused PRs should maintain clear scope boundaries. However, this does NOT exempt bugs in the specific file(s) being tested - those must be fixed in the same PR. Only bugs in unrelated files may be deferred to separate issues.
