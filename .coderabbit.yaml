# yaml-language-server: $schema=https://coderabbit.ai/integrations/schema.v2.json

language: 'en-US'

early_access: false

chat:
  auto_reply: true

issue_enrichment:
  auto_enrich:
    enabled: false

# ADVISORY GUIDELINES (Guides the AI reviewer during manual reviews)
reviews:
  profile: 'assertive'
  poem: false
  request_changes_workflow: true
  high_level_summary: true
  review_status: true
  collapse_walkthrough: false
  auto_review:
    enabled: true
    drafts: false
    base_branches:
      - develop
      - develop
      - main
  path_filters:
    - '!**/docs/docs/**'
    - '!*.html'
    - '!*.md'
    - '!*.svg'
  path_instructions:
    - path: '**/*'
      instructions: |
        Conduct a comprehensive review and reevaluate all resolved and dismissed items. Include the following validation criteria:

        ## 1. Test Coverage & Quality Validation

        ### 1.1 Test File Quality
        For any modified test files, validate:
        - ✅ **Framework Compliance**: Follow Vitest and React Testing Library best practices
            - Use `vi.mock()` for mocking (not `jest.mock()`)
            - Use `describe()`, `it()`, `test()` for test structure
            - Leverage `@testing-library/react` queries (getByRole, getByText, etc.)
            - Use `@testing-library/user-event` for simulating interactions

        - ✅ **Coverage Completeness**: Cover all code paths including:
            - Success scenarios with valid data
            - Error scenarios (network failures, GraphQL errors, validation errors)
            - Edge cases (empty data, null/undefined, boundary values)
            - Loading and pending states
            - User interactions (clicks, form submissions, navigation)
            - State changes and side effects

        - ✅ **Mock Quality**:
            - GraphQL queries/mutations use `MockedProvider` or `StaticMockLink`
            - External dependencies properly mocked
            - Mock data is realistic and comprehensive
            - Cleanup performed after tests (reset mocks, clear timers)

        - ✅ **Test Structure**:
            - Tests are isolated and don't depend on execution order
            - No disabled tests (`it.skip`, `describe.skip`, `test.skip`) unless:
            - Documented with a comment explaining why
            - Linked to an issue for re-enabling
            - Proper use of `waitFor`, `act`, and async utilities

        ### 1.2 Test File Existence
        For each modified source file with logic or UI:
        - ✅ Corresponding test file exists with naming: `*.spec.tsx`, `*.spec.ts`, `*.test.tsx`, `*.test.ts`
        - ✅ Test file is updated to reflect source changes
        - ✅ **List specific line numbers** in source files lacking test coverage

        ### 1.3 Shard Compatibility
        - ✅ Tests don't break the 12-shard parallel execution strategy
        - ✅ No shared state between tests that could cause race conditions
        - ✅ Tests complete within reasonable time (testTimeout: 30000ms)

        ## 2. Code Quality & Repository Standards

        ### 2.1 TypeScript Compliance
        - ✅ **No `any` type** without explicit JSDoc justification
        - ✅ Proper interface/type definitions for:
            - Component props with `interface` declarations
            - Function parameters and return types
            - GraphQL query/mutation variables and responses
            - State and context types
        - ✅ No TypeScript errors or `@ts-ignore` comments without explanation

        ### 2.2 GraphQL Implementation
        - ✅ Queries/mutations follow patterns in `src/GraphQl/Queries/` and `src/GraphQl/Mutations/`
        - ✅ Proper typing using `gql` template tag from `graphql-tag`
        - ✅ No duplicate queries (check for pagination inconsistencies like `first`/`last` usage)
        - ✅ Error handling implemented for all GraphQL operations:
            ```typescript
            const [mutation, { loading, error }] = useMutation(MUTATION);
            // Must handle error state in UI
            ```
        - ✅ Proper use of Apollo Client hooks (`useQuery`, `useMutation`, `useSubscription`)

        ### 2.3 React & Material-UI Best Practices
        - ✅ Functional components with proper hooks usage (useState, useEffect, useMemo, useCallback)
        - ✅ Material-UI v7 component patterns followed consistently:
            - Import from `@mui/material`
            - Use emotion for styling (`@emotion/react`)
            - Follow MUI theming patterns
        - ✅ No prop drilling; use React Context or Redux when needed
        - ✅ Proper cleanup in `useEffect`:
            ```typescript
            useEffect(() => {
            // Effect logic
            return () => {
                // Cleanup subscriptions, timers, etc.
            };
            }, [deps]);
            ```

        ### 2.4 Internationalization (i18n)
        - ✅ **Zero hardcoded user-facing strings** in UI components
        - ✅ All text uses `useTranslation()` hook with translation keys:
            ```typescript
            const { t } = useTranslation('translation', { keyPrefix: 'componentName' });
            <Button>{t('buttonLabel')}</Button>
            ```
        - ✅ New translation keys added to **all locale files**:
            - `public/locales/en/translation.json`
            - `public/locales/es/translation.json`
            - `public/locales/fr/translation.json`
            - `public/locales/hi/translation.json`
            - `public/locales/zh/translation.json`
        - ✅ Keys follow nested structure matching component hierarchy

        ### 2.5 Accessibility (a11y)
        - ✅ Proper ARIA attributes where needed:
            - `aria-label` for icon-only buttons
            - `aria-describedby` for form hints and errors
            - `aria-live` for dynamic content announcements
        - ✅ Semantic HTML and proper `role` attributes
        - ✅ Keyboard navigation support (focusable elements, tab order)
        - ✅ Screen reader compatibility (meaningful text alternatives)

        ### 2.6 Package Manager
        - ✅ Use **pnpm** commands (not npm or yarn) in documentation
        - ✅ No direct `package-lock.json` or `yarn.lock` changes (use `pnpm-lock.yaml`)

        ## 3. Documentation & Code Comments

        - ✅ **JSDoc comments** on:
            - All exported functions, classes, and interfaces
            - Complex logic requiring explanation
            - GraphQL queries/mutations (parameters, return values)
        - ✅ Auto-generated documentation updated (enforced by Check-AutoDocs job)
        - ✅ README.md or feature docs updated for new features
        - ✅ Table of Contents updated (enforced by pre-commit hook)

        ## 4. Code Issues to Identify

        Report these issues with **specific line numbers**:
        - ❌ Lines of code missing test coverage
        - ❌ Unnecessary files:
            - Build artifacts (`dist/`, `build/`, `coverage/`)
            - Dependencies (`node_modules/`, `pnpm-lock.yaml` unnecessary changes)
            - Environment files (`.env`, `.env.local`)
            - IDE configs (`.vscode/`, `.idea/`)
        - ❌ Unused imports or dead code (checked by knip)
        - ❌ Debug code left in production:
            - `console.log()`, `console.debug()`, `console.info()` in non-script files
            - Commented-out code blocks
            - TODO/FIXME comments without linked issues
        - ❌ Skipped tests without documentation

        ## 5. PR Requirements Validation

        ### 5.1 Issue Requirements
        - ✅ All acceptance criteria from linked issue addressed
        - ✅ No out-of-scope changes included
        - ✅ If bugs found in files being tested, they **must be fixed in this PR**
        - ✅ Bugs in unrelated files should be deferred to separate issues

        ### 5.2 Review Feedback Compliance
        - ✅ All previous review comments addressed or acknowledged
        - ✅ Requested changes implemented correctly
        - ✅ No unresolved conversations without explanation

        ### 5.3 PR Metadata
        - ✅ Clear, descriptive title following convention (e.g., "feat:", "fix:", "refactor:")
        - ✅ Linked to issue(s) using GitHub keywords (Fixes #1234, Resolves #5678)
        - ✅ Target branch is correct (typically `develop`)
        - ✅ No sensitive information exposed (checked by Check-Sensitive-Files job)

        ## 6. CI/CD Pipeline Compatibility

        - ✅ Changes won't break CI jobs:
            - Code Quality Checks (linting, formatting, type-checking)
            - Vitest test execution (12 shards)
            - Code coverage reporting
            - Documentation generation
            - Sensitive files check
            - MinIO compliance check
            - Knip unused code detection

        - ✅ Pre-commit hook requirements met:
            - `pnpm run format:fix` - Prettier formatting
            - `pnpm run lint-staged` - ESLint with zero warnings
            - `pnpm run typecheck` - TypeScript compilation
            - `pnpm run update:toc` - Table of Contents
            - `pnpm run check:pom` - Page Object Model checks
            - `npx knip` - Unused file detection

        - ✅ No performance regressions in test execution time

        ## 7. Security & Best Practices

        - ✅ No security vulnerabilities introduced
        - ✅ No exposed credentials:
            - API keys, tokens, passwords
            - Database connection strings
            - Third-party service credentials
        - ✅ Proper input validation and sanitization
        - ✅ No XSS vulnerabilities in user-generated content rendering
        - ✅ Secure handling of sensitive data (PII, authentication tokens)

        ## 8. Implementation Correctness

        For files under test or modification:
        - ✅ Implementation logic is correct and bug-free
        - ✅ GraphQL queries target correct schema fields
        - ✅ Data transformations and business logic are accurate
        - ✅ Error handling covers all failure scenarios
        - ✅ State management (Redux/Context) is properly implemented
        - ✅ No race conditions or memory leaks

        ## 9. Review Decision & Approval

        ### When to Require Changes (DO NOT approve):
        - Critical bugs in implementation
        - Missing test coverage for new/modified code
        - Security vulnerabilities
        - TypeScript errors
        - Missing i18n translations
        - Accessibility violations
        - Unaddressed review feedback
        - Out-of-scope changes without justification

        ### Approval Criteria (append `[approve]` tag ONLY when ALL are met):
        1. ✅ Complete test coverage with quality tests
        2. ✅ Zero code quality issues
        3. ✅ No security concerns
        4. ✅ All bugs fixed (in files being tested)
        5. ✅ Full compliance with previous feedback
        6. ✅ No unnecessary files
        7. ✅ All CI checks will pass
        8. ✅ Complete i18n support
        9. ✅ Accessibility requirements met
        10. ✅ **Zero changes needed** - even minor improvements should block approval

        **Important**: Be strict with approvals. If you suggest any improvement, do not approve.

        ## 10. Focus & Prioritization

        - **Prioritize substantive issues** over stylistic preferences
        - **Focus on CI-breaking issues** and production bugs first
        - **Highlight pattern deviations** that could cause maintenance issues
        - **Be specific**: Provide exact line numbers, not just file names
        - **Be constructive**: Suggest concrete solutions, not just problems

        ## 11. Scope Boundaries

        - Test-focused PRs should maintain clear scope boundaries
        - Bugs in the **specific files being tested MUST be fixed** in the same PR
        - Bugs in **unrelated files** should be deferred to separate issues
        - Document scope decisions clearly in review comments

  # ENFORCED VALIDATION GATES (blocks PRs programmatically)
  pre_merge_checks:
    # Enforce test file updates for modified source files
    custom_checks:
      - name: 'Test Coverage Validation'
        mode: 'error' # Blocks PR until resolved
        instructions: |
          Conduct a comprehensive review and reevaluate all resolved and dismissed items. Include the following validation criteria:

          ## 1. Test Coverage & Quality Validation

          ### 1.1 Test File Quality
          For any modified test files, validate:
          - ✅ **Framework Compliance**: Follow Vitest and React Testing Library best practices
              - Use `vi.mock()` for mocking (not `jest.mock()`)
              - Use `describe()`, `it()`, `test()` for test structure
              - Leverage `@testing-library/react` queries (getByRole, getByText, etc.)
              - Use `@testing-library/user-event` for simulating interactions

          - ✅ **Coverage Completeness**: Cover all code paths including:
              - Success scenarios with valid data
              - Error scenarios (network failures, GraphQL errors, validation errors)
              - Edge cases (empty data, null/undefined, boundary values)
              - Loading and pending states
              - User interactions (clicks, form submissions, navigation)
              - State changes and side effects

          - ✅ **Mock Quality**:
              - GraphQL queries/mutations use `MockedProvider` or `StaticMockLink`
              - External dependencies properly mocked
              - Mock data is realistic and comprehensive
              - Cleanup performed after tests (reset mocks, clear timers)

          - ✅ **Test Structure**:
              - Tests are isolated and don't depend on execution order
              - No disabled tests (`it.skip`, `describe.skip`, `test.skip`) unless:
              - Documented with a comment explaining why
              - Linked to an issue for re-enabling
              - Proper use of `waitFor`, `act`, and async utilities

          ### 1.2 Test File Existence
          For each modified source file with logic or UI:
          - ✅ Corresponding test file exists with naming: `*.spec.tsx`, `*.spec.ts`, `*.test.tsx`, `*.test.ts`
          - ✅ Test file is updated to reflect source changes
          - ✅ **List specific line numbers** in source files lacking test coverage

          ### 1.3 Shard Compatibility
          - ✅ Tests don't break the 12-shard parallel execution strategy
          - ✅ No shared state between tests that could cause race conditions
          - ✅ Tests complete within reasonable time (testTimeout: 30000ms)

          ## 2. Code Quality & Repository Standards

          ### 2.1 TypeScript Compliance
          - ✅ **No `any` type** without explicit JSDoc justification
          - ✅ Proper interface/type definitions for:
              - Component props with `interface` declarations
              - Function parameters and return types
              - GraphQL query/mutation variables and responses
              - State and context types
          - ✅ No TypeScript errors or `@ts-ignore` comments without explanation

          ### 2.2 GraphQL Implementation
          - ✅ Queries/mutations follow patterns in `src/GraphQl/Queries/` and `src/GraphQl/Mutations/`
          - ✅ Proper typing using `gql` template tag from `graphql-tag`
          - ✅ No duplicate queries (check for pagination inconsistencies like `first`/`last` usage)
          - ✅ Error handling implemented for all GraphQL operations:
              ```typescript
              const [mutation, { loading, error }] = useMutation(MUTATION);
              // Must handle error state in UI
              ```
          - ✅ Proper use of Apollo Client hooks (`useQuery`, `useMutation`, `useSubscription`)

          ### 2.3 React & Material-UI Best Practices
          - ✅ Functional components with proper hooks usage (useState, useEffect, useMemo, useCallback)
          - ✅ Material-UI v7 component patterns followed consistently:
              - Import from `@mui/material`
              - Use emotion for styling (`@emotion/react`)
              - Follow MUI theming patterns
          - ✅ No prop drilling; use React Context or Redux when needed
          - ✅ Proper cleanup in `useEffect`:
              ```typescript
              useEffect(() => {
              // Effect logic
              return () => {
                  // Cleanup subscriptions, timers, etc.
              };
              }, [deps]);
              ```

          ### 2.4 Internationalization (i18n)
          - ✅ **Zero hardcoded user-facing strings** in UI components
          - ✅ All text uses `useTranslation()` hook with translation keys:
              ```typescript
              const { t } = useTranslation('translation', { keyPrefix: 'componentName' });
              <Button>{t('buttonLabel')}</Button>
              ```
          - ✅ New translation keys added to **all locale files**:
              - `public/locales/en/translation.json`
              - `public/locales/es/translation.json`
              - `public/locales/fr/translation.json`
              - `public/locales/hi/translation.json`
              - `public/locales/zh/translation.json`
          - ✅ Keys follow nested structure matching component hierarchy

          ### 2.5 Accessibility (a11y)
          - ✅ Proper ARIA attributes where needed:
              - `aria-label` for icon-only buttons
              - `aria-describedby` for form hints and errors
              - `aria-live` for dynamic content announcements
          - ✅ Semantic HTML and proper `role` attributes
          - ✅ Keyboard navigation support (focusable elements, tab order)
          - ✅ Screen reader compatibility (meaningful text alternatives)

          ### 2.6 Package Manager
          - ✅ Use **pnpm** commands (not npm or yarn) in documentation
          - ✅ No direct `package-lock.json` or `yarn.lock` changes (use `pnpm-lock.yaml`)

          ## 3. Documentation & Code Comments

          - ✅ **JSDoc comments** on:
              - All exported functions, classes, and interfaces
              - Complex logic requiring explanation
              - GraphQL queries/mutations (parameters, return values)
          - ✅ Auto-generated documentation updated (enforced by Check-AutoDocs job)
          - ✅ README.md or feature docs updated for new features
          - ✅ Table of Contents updated (enforced by pre-commit hook)

          ## 4. Code Issues to Identify

          Report these issues with **specific line numbers**:
          - ❌ Lines of code missing test coverage
          - ❌ Unnecessary files:
              - Build artifacts (`dist/`, `build/`, `coverage/`)
              - Dependencies (`node_modules/`, `pnpm-lock.yaml` unnecessary changes)
              - Environment files (`.env`, `.env.local`)
              - IDE configs (`.vscode/`, `.idea/`)
          - ❌ Unused imports or dead code (checked by knip)
          - ❌ Debug code left in production:
              - `console.log()`, `console.debug()`, `console.info()` in non-script files
              - Commented-out code blocks
              - TODO/FIXME comments without linked issues
          - ❌ Skipped tests without documentation

          ## 5. PR Requirements Validation

          ### 5.1 Issue Requirements
          - ✅ All acceptance criteria from linked issue addressed
          - ✅ No out-of-scope changes included
          - ✅ If bugs found in files being tested, they **must be fixed in this PR**
          - ✅ Bugs in unrelated files should be deferred to separate issues

          ### 5.2 Review Feedback Compliance
          - ✅ All previous review comments addressed or acknowledged
          - ✅ Requested changes implemented correctly
          - ✅ No unresolved conversations without explanation

          ### 5.3 PR Metadata
          - ✅ Clear, descriptive title following convention (e.g., "feat:", "fix:", "refactor:")
          - ✅ Linked to issue(s) using GitHub keywords (Fixes #1234, Resolves #5678)
          - ✅ Target branch is correct (typically `develop`)
          - ✅ No sensitive information exposed (checked by Check-Sensitive-Files job)

          ## 6. CI/CD Pipeline Compatibility

          - ✅ Changes won't break CI jobs:
              - Code Quality Checks (linting, formatting, type-checking)
              - Vitest test execution (12 shards)
              - Code coverage reporting
              - Documentation generation
              - Sensitive files check
              - MinIO compliance check
              - Knip unused code detection

          - ✅ Pre-commit hook requirements met:
              - `pnpm run format:fix` - Prettier formatting
              - `pnpm run lint-staged` - ESLint with zero warnings
              - `pnpm run typecheck` - TypeScript compilation
              - `pnpm run update:toc` - Table of Contents
              - `pnpm run check:pom` - Page Object Model checks
              - `npx knip` - Unused file detection

          - ✅ No performance regressions in test execution time

          ## 7. Security & Best Practices

          - ✅ No security vulnerabilities introduced
          - ✅ No exposed credentials:
              - API keys, tokens, passwords
              - Database connection strings
              - Third-party service credentials
          - ✅ Proper input validation and sanitization
          - ✅ No XSS vulnerabilities in user-generated content rendering
          - ✅ Secure handling of sensitive data (PII, authentication tokens)

          ## 8. Implementation Correctness

          For files under test or modification:
          - ✅ Implementation logic is correct and bug-free
          - ✅ GraphQL queries target correct schema fields
          - ✅ Data transformations and business logic are accurate
          - ✅ Error handling covers all failure scenarios
          - ✅ State management (Redux/Context) is properly implemented
          - ✅ No race conditions or memory leaks

          ## 9. Review Decision & Approval

          ### When to Require Changes (DO NOT approve):
          - Critical bugs in implementation
          - Missing test coverage for new/modified code
          - Security vulnerabilities
          - TypeScript errors
          - Missing i18n translations
          - Accessibility violations
          - Unaddressed review feedback
          - Out-of-scope changes without justification

          ### Approval Criteria (append `[approve]` tag ONLY when ALL are met):
          1. ✅ Complete test coverage with quality tests
          2. ✅ Zero code quality issues
          3. ✅ No security concerns
          4. ✅ All bugs fixed (in files being tested)
          5. ✅ Full compliance with previous feedback
          6. ✅ No unnecessary files
          7. ✅ All CI checks will pass
          8. ✅ Complete i18n support
          9. ✅ Accessibility requirements met
          10. ✅ **Zero changes needed** - even minor improvements should block approval

          **Important**: Be strict with approvals. If you suggest any improvement, do not approve.

          ## 10. Focus & Prioritization

          - **Prioritize substantive issues** over stylistic preferences
          - **Focus on CI-breaking issues** and production bugs first
          - **Highlight pattern deviations** that could cause maintenance issues
          - **Be specific**: Provide exact line numbers, not just file names
          - **Be constructive**: Suggest concrete solutions, not just problems

          ## 11. Scope Boundaries

          - Test-focused PRs should maintain clear scope boundaries
          - Bugs in the **specific files being tested MUST be fixed** in the same PR
          - Bugs in **unrelated files** should be deferred to separate issues
          - Document scope decisions clearly in review comments
