"use strict";(globalThis.webpackChunkdocs=globalThis.webpackChunkdocs||[]).push([[75068],{29438:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var s=i(30758);const t={},r=s.createContext(t);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},63806:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"docs/developer-resources/introduction","title":"Introduction","description":"Welcome to Talawa-Admin","source":"@site/docs/docs/developer-resources/introduction.md","sourceDirName":"docs/developer-resources","slug":"/developer-resources/introduction","permalink":"/docs/developer-resources/introduction","draft":false,"unlisted":false,"editUrl":"https://github.com/PalisadoesFoundation/talawa-admin/edit/develop/docs/docs/docs/developer-resources/introduction.md","tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"id":"introduction","title":"Introduction","slug":"/developer-resources/introduction","sidebar_position":10},"sidebar":"tutorialSidebar","previous":{"title":"Installation","permalink":"/docs/developer-resources/installation"},"next":{"title":"Security Guidelines","permalink":"/docs/developer-resources/security"}}');var t=i(86070),r=i(29438);const o={id:"introduction",title:"Introduction",slug:"/developer-resources/introduction",sidebar_position:10},a=void 0,l={},c=[{value:"Before You Begin",id:"before-you-begin",level:2},{value:"Understand the Code Before Changing",id:"understand-the-code-before-changing",level:3},{value:"Refactor in Small, Incremental Steps",id:"refactor-in-small-incremental-steps",level:3},{value:"Prioritize Testing",id:"prioritize-testing",level:3},{value:"Separate Refactoring from Feature Development",id:"separate-refactoring-from-feature-development",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Embrace Modularity",id:"embrace-modularity",level:3},{value:"Focus on Readability and Maintainability",id:"focus-on-readability-and-maintainability",level:3},{value:"Document Your Code:",id:"document-your-code",level:3},{value:"Leverage TypeScript&#39;s Features",id:"leverage-typescripts-features",level:3}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Welcome to Talawa-Admin"}),"\n",(0,t.jsxs)(n.p,{children:["This section outlines the coding standards and best practices to follow when refactoring or writing TypeScript code for Talawa projects. Following these guidelines ensures readability, maintainability, and scalability across the codebase. Refer to ",(0,t.jsx)(n.code,{children:"CODE_STYLE.md"})," for coding conventions to follow when contributing."]}),"\n",(0,t.jsx)(n.h2,{id:"before-you-begin",children:"Before You Begin"}),"\n",(0,t.jsx)(n.p,{children:"It's important to consider these factors before you start."}),"\n",(0,t.jsx)(n.h3,{id:"understand-the-code-before-changing",children:"Understand the Code Before Changing"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Thoroughly understand the existing code's purpose and functionality before attempting to refactor it."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Identify areas for improvement and define clear refactoring goals."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"refactor-in-small-incremental-steps",children:"Refactor in Small, Incremental Steps"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Avoid large, sweeping changes. Break down refactoring into small, manageable tasks and PRs."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Commit changes often: to track progress and easily revert if issues arise."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"prioritize-testing",children:"Prioritize Testing"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Write comprehensive unit tests before refactoring to ensure the code's behavior remains consistent after changes."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Run tests frequently during and after refactoring to catch regressions early."}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"separate-refactoring-from-feature-development",children:"Separate Refactoring from Feature Development"}),"\n",(0,t.jsx)(n.p,{children:"Avoid mixing refactoring with new feature development in the same commit or branch to maintain clarity and ease debugging."}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.p,{children:"Follow these guidelines for writing reusable TypeScript code."}),"\n",(0,t.jsx)(n.h3,{id:"embrace-modularity",children:"Embrace Modularity"}),"\n",(0,t.jsx)(n.p,{children:"Modular design is a cornerstone of maintainable software architecture. By breaking down your codebase into smaller, well-defined parts, you make it easier to understand, test, and scale."}),"\n",(0,t.jsxs)(n.p,{children:["To explore how modularity translates into building consistent and maintainable front-end elements, refer to the ",(0,t.jsx)(n.a,{href:"/docs/developer-resources/reusable-components",children:"Reusable Components guide"})]}),"\n",(0,t.jsx)(n.h3,{id:"focus-on-readability-and-maintainability",children:"Focus on Readability and Maintainability"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Maintain Consistent Naming Conventions and Code Style:"})," Adhere to established naming conventions for variables, functions, and types, and use consistent code formatting. This enhances readability and makes it easier to navigate and understand the codebase."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Break down complex functions:"})," Use smaller, more focused units."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Eliminate code duplication:"})," Extract common logic into reusable functions or components."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use appropriate data types:"})," Leverage TypeScript's type system for enhanced type safety and clarity."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"document-your-code",children:"Document Your Code:"}),"\n",(0,t.jsx)(n.p,{children:"Use TSDoc comments to document functions, classes, and interfaces, explaining their purpose, parameters, and return values. This improves code readability and makes it easier for others (and your future self) to understand and use your reusable components."}),"\n",(0,t.jsx)(n.h3,{id:"leverage-typescripts-features",children:"Leverage TypeScript's Features"}),"\n",(0,t.jsx)(n.p,{children:"There are many useful practices that you should consider when writing TypeScript code for our repositories. These include the following:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Utilize Generics:"})," By using generics, you create a scalable and maintainable foundation for your application, allowing for easy expansion and modification as your business needs evolve. Employ generics to create functions, classes, and interfaces that can work with various data types without sacrificing type safety. This allows you to write a single piece of logic that adapts to different inputs."]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Here is an itemized list of advantages:"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"Code Reusability: The same interface can be implemented for different types, reducing duplication."}),"\n",(0,t.jsx)(n.li,{children:"Type Safety: TypeScript ensures that the correct types are used in each implementation."}),"\n",(0,t.jsx)(n.li,{children:"Flexibility: You can easily create new repositories for new entities without writing redundant code."}),"\n",(0,t.jsx)(n.li,{children:"Consistency: All repositories follow the same structure, making the codebase more predictable and easier to maintain."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Generics allow you to write a single piece of logic that adapts to different inputs."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"    function identity<T>(value: T): T {\n        return value;\n    }\n"})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"For instance, a generic Repository interface can handle different entities like products, orders, or customers."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface Repository<T> {\ngetById(id: string): Promise<T>;\ngetAll(): Promise<T[]>;\ncreate(item: T): Promise<void>;\nupdate(id: string, item: Partial<T>): Promise<void>;\ndelete(id: string): Promise<void>;\n}\n\nclass ProductRepository implements Repository<Product> {\n// Implementation here\n}\n\nclass OrderRepository implements Repository<Order> {\n// Implementation here\n}\n"})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Define Clear Interfaces and Types:"})," Use interfaces to define the shape of objects and types for complex data structures. This provides clear contracts for how data should be structured, promoting consistency and easier integration."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"    interface User {\n        id: string;\n        name: string;\n        email: string;\n    }\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Utility Types:"})," Take advantage of TypeScript's built-in utility types like Partial, Readonly, Pick, and Omit to create new types based on existing ones, simplifying complex type manipulations and promoting code reuse in type definitions."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"    // Makes all properties of User optional\n    type OptionalUser = Partial<User>; \n"})}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement Type Guards:"})," Use type guards to perform runtime type checking, ensuring your code handles different types correctly and safely within conditional blocks."]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"    function isNumber(value: unknown): value is number {\n        return typeof value === 'number';\n    }\n"})}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Consider using enums:"})," When sets of related constants are used"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Use access modifiers:"})," Consider (public, private, protected) modifier for better encapsulation in classes."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.strong,{children:["Avoid ",(0,t.jsx)(n.code,{children:"any"})]})," Minimize the use of the ",(0,t.jsx)(n.code,{children:"any"})," type as it defeats the purpose of TypeScript's type safety. Strive to provide explicit types or leverage type inference where possible."]}),"\n"]}),"\n"]})]})}function p(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);