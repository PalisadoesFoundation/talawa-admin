INSTRUCTIONS:

    understand this repository, read .md files for clarity and ask if any doubts
    IMPORTANT: Never use git add . - always add files individually with short, clear commit messages


Isuue:

Phase 1: Admin — Extract UserTableRow reusable component #5085
Open
0 / 3
0 of 3 issues completed
Parent:
Reusable Components Refactoring - Parent Issue
Open
Phase 1: Admin — Extract UserTableRow reusable component
#5085
0 / 3
0 of 3 issues completed
Parent:
#4997
@palisadoes
Description
palisadoes
opened 3 weeks ago · edited by palisadoes
Contributor
Note
This is going to require someone with extensive experience with the repository

Prerequisite issues:

Phase 1: Shared — Extract ProfileAvatarDisplay as reusable component #5083
Phase 1: Admin — Establish AdminPortal directory structure #5084
Related PR

feat: Phase 1: Admin — Extract UserTableRow reusable component #5969
Summary

Extract an admin-only UserTableRow component to consolidate repeated user row UI (avatar, name/link, email, dates, actions) used across multiple admin screens.
Problem Statement

Admin screens like OrganizationPeople, BlockUser, and Users define similar row UIs with small inconsistencies and duplicated logic (avatars, links, actions).
Proposed Solution

Create UserTableRow under AdminPortal components, with a typed props interface under src/types/AdminPortal/.
Support flexible action configuration (e.g., Remove, Block/Unblock) and optional link navigation.
Ensure i18n coverage and TSDoc.
Target Screens

OrganizationPeople, BlockUser, Users (initial scope)
Implementation Approach (high-level)

Implement component and tests (render variants, actions, accessibility, truncation).
Refactor target screens to consume the component.
Update docs with examples and migration notes (no code samples in issue).
Deliverables

AdminPortal UserTableRow component and types
Tests with comprehensive coverage
Documentation and migration checklist
Acceptance Criteria

Target screens render via UserTableRow without regressions
100% coverage for new component; CI green; i18n for visible strings
Dependencies

Relies on: Phase 1 Issue “ProfileAvatarDisplay” (shared component) and “AdminPortal directory setup”.
Effort & PR Plan (summary)

~7 PRs: (1) component+tests, (2-4) migrate each screen, (5) docs, (6) a11y/QA, (7) cleanup
Context & References

Reusable component standards: https://docs-admin.talawa.io/docs/developer-resources/reusable-components
AI Generated: Provided only as a guide. This is a representation of what could be done
Examples of possible ways to extract UserTableRow reusable component.

It follows the shared-components and AdminPortal folder conventions, typed props in src/types/AdminPortal/UserTableRow/interface.ts, i18n, and a11y.
It supports both MUI DataGrid cell and classic table row contexts.
src/types/AdminPortal/UserTableRow/interface.ts
/**
 * Props and helper types for Admin UserTableRow component.
 * This component renders user information (avatar, name/link, email, joined date, actions)
 * and supports both MUI DataGrid cell and classic <tr>/<td> contexts.
 */

export interface InterfaceUserInfo {
  id: string;
  name: string;
  emailAddress?: string | null;
  avatarURL?: string | null;
  createdAt?: string | null; // ISO date
}

export type InterfaceActionVariant = 'primary' | 'success' | 'danger' | 'default';

export interface InterfaceActionButton {
  label: string;
  onClick: (user: InterfaceUserInfo) => void;
  icon?: React.ReactElement;
  variant?: InterfaceActionVariant;
  testId?: string;
  disabled?: boolean;
  ariaLabel?: string;
}

export interface InterfaceUserTableRowProps {
  user: InterfaceUserInfo;
  rowNumber?: number;
  linkPath?: string;               // e.g. `/member/${user.id}`
  actions?: InterfaceActionButton[];
  showJoinedDate?: boolean;
  onRowClick?: (user: InterfaceUserInfo) => void;
  isDataGrid?: boolean;            // true for DataGrid cell; false for <tr>/<td>
  compact?: boolean;               // reduce spacing
  testIdPrefix?: string;           // e.g. "org-people"
}
src/components/AdminPortal/UserTableRow/UserTableRow.tsx
import React, { memo, useCallback, MouseEvent } from 'react';
import { Link } from 'react-router-dom';
import dayjs from 'dayjs';
import { useTranslation } from 'react-i18next';
import Box from '@mui/material/Box';
import Stack from '@mui/material/Stack';
import Typography from '@mui/material/Typography';
import Button from '@mui/material/Button';
import Tooltip from '@mui/material/Tooltip';
import { InterfaceUserTableRowProps, InterfaceActionButton } from '../../../types/AdminPortal/UserTableRow/interface'; // path adjusted below
// NOTE: When placed in repo, please ensure the relative import from src/types is correct:
// import { InterfaceUserTableRowProps, InterfaceActionButton } from 'types/AdminPortal/UserTableRow/interface';

import { ProfileAvatarDisplay } from 'shared-components/ProfileAvatarDisplay/ProfileAvatarDisplay';

const mapVariantToColor = (v: InterfaceActionButton['variant']) => {
  switch (v) {
    case 'danger':
      return 'error';
    case 'success':
      return 'success';
    case 'primary':
      return 'primary';
    default:
      return 'inherit';
  }
};

/**
 * UserTableRow (AdminPortal)
 * Renders a user line with avatar, name/link, email, joined date, and configurable actions.
 * - DataGrid mode: returns a Box suitable for renderCell
 * - Table mode: returns a <tr> with <td>s
 *
 * A11y:
 * - Avatar has meaningful alt text via ProfileAvatarDisplay.
 * - Action buttons rely on label and optional ariaLabel.
 * - Row clickable via onRowClick; keyboard navigation is handled by parent table/grid.
 */
export const UserTableRow: React.FC<InterfaceUserTableRowProps> = memo((props) => {
  const {
    user,
    rowNumber,
    linkPath,
    actions = [],
    showJoinedDate = true,
    onRowClick,
    isDataGrid = true,
    compact = false,
    testIdPrefix = 'user-table-row',
  } = props;

  const { t } = useTranslation();
  const email = user.emailAddress || t('common.no_email', 'No email');
  const name = user.name || t('common.no_name', 'No name');
  const joined = user.createdAt ? dayjs(user.createdAt).format('YYYY-MM-DD') : t('common.na', 'N/A');

  const handleRowClick = useCallback(
    (e: MouseEvent) => {
      if (!onRowClick) return;
      // don't trigger onRowClick if a button inside was clicked
      const target = e.target as HTMLElement;
      if (target.closest('button')) return;
      onRowClick(user);
    },
    [onRowClick, user],
  );

  const renderActions = () => {
    if (!actions?.length) return null;
    return (
      <Stack direction="row" spacing={compact ? 0.5 : 1}>
        {actions.map((action, idx) => {
          const color = mapVariantToColor(action.variant);
          const label = action.label;
          const aria = action.ariaLabel || label;

          return (
            <Tooltip key={idx} title={label}>
              <span>
                <Button
                  size={compact ? 'small' : 'medium'}
                  variant="outlined"
                  color={color as any}
                  onClick={() => action.onClick(user)}
                  disabled={action.disabled}
                  aria-label={aria}
                  data-testid={action.testId || `${testIdPrefix}-action-${idx}`}
                  startIcon={action.icon}
                >
                  {label}
                </Button>
              </span>
            </Tooltip>
          );
        })}
      </Stack>
    );
  };

  const left = (
    <Stack direction="row" alignItems="center" spacing={compact ? 1 : 1.5}>
      <ProfileAvatarDisplay
        name={name}
        avatarURL={user.avatarURL}
        size={compact ? 'small' : 'medium'}
        alt={t('avatar.alt_user', { name })}
        showBorder={false}
        testId={`${testIdPrefix}-avatar-${user.id}`}
      />
      <Stack spacing={0}>
        {linkPath ? (
          <Typography variant={compact ? 'body2' : 'body1'} component={Link} to={linkPath}>
            {name}
          </Typography>
        ) : (
          <Typography variant={compact ? 'body2' : 'body1'}>{name}</Typography>
        )}
        <Typography variant="caption" color="text.secondary" data-testid={`${testIdPrefix}-email-${user.id}`}>
          {email}
        </Typography>
      </Stack>
    </Stack>
  );

  const right = (
    <Stack direction="row" spacing={compact ? 1 : 2} alignItems="center">
      {showJoinedDate && (
        <Typography variant="body2" color="text.secondary" data-testid={`${testIdPrefix}-joined-${user.id}`}>
          {t('user.joined_on', 'Joined')}: {joined}
        </Typography>
      )}
      {renderActions()}
    </Stack>
  );

  if (isDataGrid) {
    return (
      <Box
        onClick={onRowClick ? handleRowClick : undefined}
        sx={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'space-between',
          gap: compact ? 1 : 2,
          width: '100%',
          cursor: onRowClick ? 'pointer' : 'default',
        }}
        data-testid={`${testIdPrefix}-gridcell-${user.id}`}
        aria-label={t('user.row_aria', 'User row')}
      >
        {left}
        {right}
      </Box>
    );
  }

  // Classic table row
  return (
    <tr
      onClick={onRowClick ? handleRowClick : undefined}
      style={{ cursor: onRowClick ? 'pointer' : 'default' }}
      data-testid={`${testIdPrefix}-tr-${user.id}`}
      aria-label={t('user.row_aria', 'User row')}
    >
      {typeof rowNumber === 'number' && <td data-testid={`${testIdPrefix}-no-${user.id}`}>{rowNumber}</td>}
      <td>{left}</td>
      {showJoinedDate && <td>{joined}</td>}
      <td>{renderActions()}</td>
    </tr>
  );
});

// Re-export as default if preferred
export default UserTableRow;
src/components/AdminPortal/UserTableRow/UserTableRow.spec.tsx
import React from 'react';
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { UserTableRow } from './UserTableRow';
import type { InterfaceUserInfo } from '../../../types/AdminPortal/UserTableRow/interface'; // adjust to 'types/...' in repo

const user: InterfaceUserInfo = {
  id: 'u1',
  name: 'Admin User',
  emailAddress: 'admin@example.com',
  avatarURL: null,
  createdAt: '2024-01-15T00:00:00.000Z',
};

describe('UserTableRow', () => {
  it('renders DataGrid cell view with avatar, name, email, and joined date', () => {
    render(
      <UserTableRow
        user={user}
        isDataGrid
        showJoinedDate
        linkPath={`/member/${user.id}`}
        actions={[]}
        testIdPrefix="spec"
      />,
    );

    expect(screen.getByTestId('spec-avatar-u1')).toBeInTheDocument();
    expect(screen.getByText('Admin User')).toBeInTheDocument();
    expect(screen.getByText('admin@example.com')).toBeInTheDocument();
    expect(screen.getByTestId('spec-joined-u1')).toBeInTheDocument();
  });

  it('fires onRowClick when clicking non-button area (grid mode)', () => {
    const onRowClick = vi.fn();
    render(<UserTableRow user={user} isDataGrid onRowClick={onRowClick} testIdPrefix="spec" />);
    fireEvent.click(screen.getByTestId('spec-gridcell-u1'));
    expect(onRowClick).toHaveBeenCalledWith(user);
  });

  it('does not fire onRowClick when clicking an action button', () => {
    const onRowClick = vi.fn();
    const onAction = vi.fn();
    render(
      <UserTableRow
        user={user}
        isDataGrid
        onRowClick={onRowClick}
        actions={[{ label: 'Remove', onClick: onAction, variant: 'danger', testId: 'removeBtn' }]}
        testIdPrefix="spec"
      />,
    );
    fireEvent.click(screen.getByTestId('removeBtn'));
    expect(onRowClick).not.toHaveBeenCalled();
    expect(onAction).toHaveBeenCalledWith(user);
  });

  it('renders table row view with row number', () => {
    render(<table><tbody>
      <UserTableRow user={user} isDataGrid={false} rowNumber={1} testIdPrefix="spec" />
    </tbody></table>);
    expect(screen.getByTestId('spec-no-u1')).toHaveTextContent('1');
    expect(screen.getByTestId('spec-tr-u1')).toBeInTheDocument();
  });
});
src/components/AdminPortal/UserTableRow/index.ts
export * from './UserTableRow';
Usage examples
MUI DataGrid column (Admin screen)
import { GridColDef } from '@mui/x-data-grid';
import { UserTableRow } from 'components/AdminPortal/UserTableRow/UserTableRow';

const columns: GridColDef[] = [
  {
    field: 'user',
    headerName: t('user', 'User'),
    flex: 3,
    sortable: false,
    renderCell: (params) => {
      const u = params.row as { id: string; name: string; emailAddress?: string; avatarURL?: string; createdAt?: string; };
      return (
        <UserTableRow
          user={u}
          isDataGrid
          showJoinedDate
          linkPath={`/member/${u.id}`}
          actions={[
            { label: t('remove', 'Remove'), onClick: handleRemove, variant: 'danger', testId: `remove-${u.id}` },
          ]}
          onRowClick={(user) => navigate(`/member/${user.id}`)}
          compact={false}
          testIdPrefix="org-people"
        />
      );
    },
  },
];
Classic table row (Admin screen with Bootstrap/Table)
import Table from 'react-bootstrap/Table';
import { UserTableRow } from 'components/AdminPortal/UserTableRow/UserTableRow';

<Table responsive hover>
  <thead>
    <tr>
      <th>#</th>
      <th>{t('user', 'User')}</th>
      <th>{t('joined', 'Joined')}</th>
      <th>{t('actions', 'Actions')}</th>
    </tr>
  </thead>
  <tbody>
    {users.map((u, idx) => (
      <UserTableRow
        key={u.id}
        user={u}
        rowNumber={idx + 1}
        isDataGrid={false}
        showJoinedDate
        actions={[
          { label: t('block', 'Block'), onClick: handleBlock, variant: 'success', testId: `block-${u.id}` },
        ]}
        onRowClick={(user) => navigate(`/member/${user.id}`)}
        compact
        testIdPrefix="block-user"
      />
    ))}
  </tbody>
</Table>
Notes

Update the import from 'types/AdminPortal/UserTableRow/interface' using your repo’s alias setup (e.g., tsconfig paths). In this snippet, the relative import comment shows where to adjust.
Avatar dependency: ProfileAvatarDisplay should be implemented at src/shared-components/ProfileAvatarDisplay/ProfileAvatarDisplay.tsx per Phase 1: Shared — Extract ProfileAvatarDisplay as reusable component #5083, with its props in src/types/shared-components/ProfileAvatarDisplay/interface.ts.
i18n: keys like user.joined_on, common.no_email, common.no_name should be added if not present.
A11y: Buttons have aria-labels; the row/container uses aria-label for screen readers.


Reusable Components
Shared components are UI and functional elements used across multiple sections of the application.

This guide outlines how to create and manage these components to ensure a unified design system and efficient code reuse.

Quick reference
Admin UI:

src/components/AdminPortal/**
src/types/AdminPortal/**

User UI

src/components/UserPortal/**
src/types/UserPortal/**

Shared UI

src/shared-components/**
src/types/shared-components/**

Props definitions

interface.ts only (no inline interfaces)
Exports

PascalCase, name matches folder/file
Tests

colocated .spec.tsx
target 100% test code coverage
i18n

all user-visible text uses keys
TSDoc

brief headers on components and interfaces
Component Architecture
It's important to understand structure and behavior of shared components before creating or refactoring them.

Folder Layout
Use the following path structure for shared components.

src/
  components/
    AdminPortal/                    # Admin-only UI and hooks
      UserTableRow/
        UserTableRow.tsx
        UserTableRow.spec.tsx
      hooks/
        useCursorPagination.ts
        useCursorPagination.spec.ts
    UserPortal/                     # User-only UI and hooks
      ...
  shared-components/                # Shared UI (kebab-case base, PascalCase children)
    ProfileAvatarDisplay/
      ProfileAvatarDisplay.tsx
      ProfileAvatarDisplay.spec.tsx
    BaseModal/
      BaseModal.tsx
      BaseModal.spec.tsx
    EmptyState/
      EmptyState.tsx
      EmptyState.spec.tsx
    LoadingState/
      LoadingState.tsx
      LoadingState.spec.tsx
  types/
    AdminPortal/                    # Admin-only types
      UserTableRow/
        interface.ts
      Pagination/
        interface.ts
    UserPortal/                     # User-only types (as needed)
      ...
    shared-components/              # Shared types mirror components
      ProfileAvatarDisplay/
        interface.ts
      BaseModal/
        interface.ts
      EmptyState/
        interface.ts
      LoadingState/
        interface.ts


Rationale
There are many reasons for this structure:

Clear ownership: Admin vs User portal code is easy to find.

Reuse with intent: Truly shared UI lives in one place.

Safer changes: Portal-specific changes can’t silently affect the other portal.

Faster onboarding and reviews: Predictable paths and conventions.

Placement Rules
Admin-only UI

src/components/AdminPortal/** (types in src/types/AdminPortal/**).

User-only UI

src/components/UserPortal/** (types in src/types/UserPortal/**).

Shared UI used by both portals

src/shared-components/** (types in src/types/shared-components/**).

Portal-specific hooks live under that portal (e.g., AdminPortal/hooks). Promote to shared only when used by both portals.

Naming Conventions
Use PascalCase for component and folder names (e.g., OrgCard, Button).
The types/shared-components folder is the sole exception
The component files should be PascalCase and the name should match the component (e.g., OrgCard.tsx, Button.tsx).
Tests should be named Component.spec.tsx.
Mock files should follow ComponentMock.ts.
Type interface should be defined in corresponding interface / type file.
For example: src/types/\<Portal or shared-components\>/\<Component\>/interface.ts (single source of truth for props; no inline prop interfaces).

src/
│
├── types/
    └── AdminPortal
        ├── Component
            └── interface.ts
            └── type.ts

Imports (examples)
// shared
import { ProfileAvatarDisplay } from '/shared-components/ProfileAvatarDisplay/ProfileAvatarDisplay';

// admin
import { UserTableRow } from 'components/AdminPortal/UserTableRow/UserTableRow';


i18n
All screen-visible text must use translation keys. No hardcoded strings.
Provide alt text and aria labels via i18n where user-facing.
Example:

<BaseModal
  title={t('members.remove_title')}
  confirmLabel={t('common.confirm')}
  cancelLabel={t('common.cancel')}
/>

TSDoc Documentation
Add a brief TSDoc header to:

Each component: what it does, key behaviors, important a11y notes.
Each interface.ts: props with short descriptions and defaults.
Example:

/**
 * ProfileAvatarDisplay renders a user’s image or initials fallback.
 * - Sizes: small | medium | large | custom
 * - A11y: always sets meaningful alt; handles broken image fallback
 */

Accessibility (a11y) essentials
Images: meaningful alt; fallback to initials when URL is empty/invalid.
Modals: role="dialog", aria-modal, labelled by title; focus trap; Escape to close.
Buttons/links: accessible names; keyboard operable.
Understanding Components Reuse
Learn how shared components are integrated and reused across different areas of the application.

Props Driven Design
Props-driven design focuses on building components that adapt their behavior, appearance, and content based on the props rather than hardcoded values. This approach increases flexibility and reusability, allowing the same component to serve multiple purposes across the application. By passing data, event handlers, and configuration options through props.

import React from 'react';
import styles from 'style/app-fixed.module.css';

interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary';
}

const Button: React.FC<ButtonProps> = ({
  label,
  onClick,
  variant = 'primary',
}) => {
  const variantStyle =
    variant === 'primary' ? styles.primaryButton : styles.secondaryButton;

  return (
    <button
      onClick={onClick}
      className={`${styles.buttonStyle} ${variantStyle}`}
    >
      {label}
    </button>
  );
};

export default Button;

Handling Role Based Differences
In some cases, a shared component needs to behave differently depending on the user's role. Instead of creating separate components for each role, you can handle variations through props. This ensures a single, maintainable source while keeping the UI consistent.

For example, the OrgCard component below adjusts its rendering based on the role and isMember props:

If role is admin, it shows the Manage button instead and displays admin-specific details.
If user is member, it shows a visit button.
If user is Not a member, it shows a join button.
import React from 'react';
import styles from 'style/app-fixed.module.css';
import InterfaceOrgCardProps from 'src/types/Organization/interface.ts';

const OrgCard: React.FC<InterfaceOrgCardProps> = ({
  name,
  address,
  membersCount,
  adminsCount,
  role,
  isMember,
}) => {
  return (
    <div className={styles.orgCard}>
      <div>
        <h3 className="font-semibold text-lg">{name}</h3>
        {role === 'admin' && adminsCount !== undefined && (
          <p className="text-sm text-gray-600">Admins: {adminsCount}</p>
        )}
        <p className="text-sm text-gray-600">Members: {membersCount}</p>
        <p className="text-sm text-gray-500">{address}</p>
      </div>

      <button onClick={handleClick} className={styles.orgCardButton}>
        {role === 'admin' ? 'Manage' : isMember ? 'Visit' : 'Join'}
      </button>
    </div>
  );
};

export default OrgCard;

Existing Shared Components
Below are some commonly used shared components available in the codebase.

EmptyState
EmptyState is a reusable shared component for displaying consistent empty, no-data, or no-result states across the application.
It replaces legacy .notFound CSS-based implementations and standardizes empty UI patterns.

Component Location
src/shared-components/EmptyState/

Use cases:

No search results
Empty lists or tables
No organizations / users / events
First-time onboarding states
Key features:

Optional icon, description, and action button
Built-in accessibility (role="status", aria-label)
i18n-ready (supports translation keys and plain strings)
Fully tested with 100% coverage
Example usage:

import EmptyState from 'src/shared-components/EmptyState/EmptyState';

<EmptyState
  message="noResults"
  description="tryAdjustingFilters"
  icon="person_off"
  action={{
    label: 'createNew',
    onClick: handleCreate,
    variant: 'primary',
  }}
/>;

When to Use EmptyState
Use EmptyState for:

Empty lists or tables
No search results
No organizations, users, or events
First-time or onboarding states
Filtered results returning no data
Do not use EmptyState for:

404 or route-level errors (use NotFound instead)
Component API
Import

import EmptyState from 'src/shared-components/EmptyState/EmptyState';

Props
Prop	Type	Required	Description
message	string	Yes	Primary message (i18n key or plain string)
description	string	No	Secondary supporting text
icon	string | ReactNode	No	Icon name or custom icon component
action	object	No	Optional action button configuration
className	string	No	Custom CSS class
dataTestId	string	No	Test identifier
Action Prop Shape
interface EmptyStateAction {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary' | 'outlined';
}

Usage Example
1. Simple Empty State:

<EmptyState message="noDataFound" />

2. Empty State With Icon:

<EmptyState
  icon="groups"
  message="noOrganizationsFound"
  description="createOrganizationToGetStarted"
/>

3. Search Empty State:

<EmptyState
  icon="search"
  message="noResultsFound"
  description={tCommon('noResultsFoundFor', {
    query: searchTerm,
  })}
/>

4. Empty State With Action Button:

<EmptyState
  icon="person_off"
  message="noUsersFound"
  description="inviteUsersToGetStarted"
  action={{
    label: 'inviteUser',
    onClick: handleInvite,
    variant: 'primary',
  }}
/>

ErrorBoundaryWrapper
ErrorBoundaryWrapper is a error boundary component that catches JavaScript errors in child components, logs them, and displays a fallback UI instead of crashing the entire application.

Use cases:

Wrapping critical components that might throw render errors
Protecting modals, forms, and complex UI sections
Providing graceful error recovery for users
Integrating with error tracking services (e.g., Sentry, LogRocket)
Key features:

Catches render errors that try-catch cannot handle
Provides default and custom fallback UI options
Integrates with toast notification system
Supports error recovery via reset mechanism
Allows error logging/tracking integration
Fully accessible (keyboard navigation, screen reader support)
Fully tested with 100% coverage
Example usage:

import { ErrorBoundaryWrapper } from 'src/shared-components/ErrorBoundaryWrapper';

// Basic usage with default fallback
<ErrorBoundaryWrapper>
  <YourComponent />
</ErrorBoundaryWrapper>

// With custom error message and logging
<ErrorBoundaryWrapper
  errorMessage={t('errors.defaultErrorMessage')}
  onError={(error, info) => logToService(error, info)}
  onReset={() => navigate('/dashboard')}
>
  <ComplexModal />
</ErrorBoundaryWrapper>

// Default fallback with custom i18n strings
<ErrorBoundaryWrapper
  fallbackTitle={t('errors.title')}
  fallbackErrorMessage={t('errors.defaultErrorMessage')}
  resetButtonText={t('errors.resetButton')}
  resetButtonAriaLabel={t('errors.resetButtonAriaLabel')}
>
  <ComplexModal />
</ErrorBoundaryWrapper>

// With custom fallback component
const CustomErrorFallback = ({ error, onReset }) => (
  <div>
    <h2>Custom Error UI</h2>
    <p>{error?.message}</p>
    <button onClick={onReset}>Retry</button>
  </div>
);

<ErrorBoundaryWrapper fallbackComponent={CustomErrorFallback}>
  <Modal />
</ErrorBoundaryWrapper>

// With custom JSX fallback
<ErrorBoundaryWrapper
  fallback={<div>Something went wrong. Please refresh.</div>}
>
  <ComplexForm />
</ErrorBoundaryWrapper>

// Disable toast notifications
<ErrorBoundaryWrapper showToast={false}>
  <Component />
</ErrorBoundaryWrapper>

Props
Prop	Type	Required	Description
children	ReactNode	Yes	Child components to wrap with error boundary
fallback	ReactNode	No	Custom JSX fallback UI
fallbackComponent	React.ComponentType<InterfaceErrorFallbackProps>	No	Custom fallback component that receives error and onReset props
errorMessage	string	No	Custom error message for toast notification
showToast	boolean	No	Whether to show toast notification (default: true)
onError	function	No	Callback invoked when error is caught
onReset	function	No	Callback invoked when user clicks reset button
fallbackTitle	string	No	Custom error message for default UI
fallbackErrorMessage	string	No	Custom error message for default UI
resetButtonText	string	No	Custom error message for default UI
resetButtonAriaLabel	string	No	Custom error message for default UI
Accessibility:

Default fallback includes role="alert" and aria-live="assertive"
Reset button is keyboard accessible (Enter and Space keys)
Screen reader friendly error messages
High contrast and dark mode support
Relationship with Loading States
Use LoadingState while data is being fetched
Render EmptyState only after loading completes
Never show EmptyState during an active loading state
Migration Guidance
Legacy .notFound CSS patterns are deprecated
All new empty-state implementations must use EmptyState
Existing screens should be migrated incrementally
Creating Shared Components
This section provides guidance on our shared components policy.

When Not to Create a Shared Component
Avoid placing a component in the shared folder if:

It's used in only one screen or context.
The design is too unique to be reused elsewhere.
Instead, keep such components in their specific module.

When to Create a Shared Component
Create a shared component if:

It's being used at multiple places.
Only props differ, not the core layout or logic.
It represents a common design pattern (like a card, button, etc.).
It's likely to be used in the future.
Defining a Strict Props Structure
Each shared component must define a clear, typed interface for its props, placed in a corresponding interface.ts file.

Why Strict Typing Matters
Strict typing is crucial when building reusable components, as these components are meant to be used across different modules, teams, and contexts. By defining clear and specific TypeScript interfaces for props, you ensure that each component communicates exactly what is expected and how it should behave, eliminating ambiguity for other developers who reuse it.

Type props act as a form of self-documentation, providing instant clarity through autocompletion and inline hints when a component is imported elsewhere. This helps prevent misuse, such as passing unsupported data or missing required props, which can lead to inconsistent UI behavior.

It also ensures that any changes in shared components are propagated safely, with TypeScript catching any incompatible usage at build time instead of letting them cause runtime errors. Ultimately, strict typing keeps your reusable code reliable, maintainable, and predictable, ensuring that they behave consistently wherever they are used in the project.

Key Rules
Always use TypeScript interfaces, avoid using any.
Avoid passing entire objects, instead destructure and pass only required fields.
Each prop should serve a single purpose (data, action, or style control).
Use clear, descriptive prop names like isMember, variant, or role instead of generic terms like flag or type.
Examples
Role based props: When a component behaves differently for user types (admin / user), define a role prop to handle that difference cleanly.

interface InterfaceOrgCardProps {
  name: string;
  address: string;
  membersCount: number;
  adminsCount?: number;
  role: 'admin' | 'user';
  isMember?: boolean;
}

Variant based props: For components with multiple design or behavior styles (like buttons or cards), define a variant prop.

interface ButtonProps {
  label: string;
  onClick: () => void;
  variant?: 'primary' | 'secondary' | 'outlined';
}

The variant prop helps the component adapt its appearance dynamically:
primary → For main action on a page (example: Save, Submit).
secondary → For supporting action (example: Cancel, Edit).
outlined → For neutral or optional actions (example: Learn more, Back).
Styling Guidelines
Use existing global or shared CSS modules whenever possible to maintain consistency.
Avoid inline styles unles necessary for dynamic cases.
When defining styles, prefer semantic class names (e.g., buttonPrimary, cardHeader).
Testing Shared Component
Each shared component must include a corresponding test file (Component.spec.tsx)
Refer to the testing page of the documentation website
Document Your Code
Use TSDoc comments to document functions, classes, and interfaces within reusable components. Clearly describe the component's purpose, its props and any return value. This practice not only improves readability but also helps maintain consistency across shared components, especially when they are used by multiple developers or teams. Well-documented props and behavior makes it easier for others to quickly understand how to use, extend, or debug the component without needing to inspect its internal implementation.

/**
 * Button Component
 *
 * Reusable button for primary, secondary, or outlined actions across the app.
 *
 * @param {ButtonProps} props - The props for the button.
 * @returns {JSX.Element} The rendered button element.
 *
 * @example
 * <Button label="Save" onClick={handleSave} variant="primary" />
 */